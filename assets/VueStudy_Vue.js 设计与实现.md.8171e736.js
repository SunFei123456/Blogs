import{_ as e,o,c,O as d}from"./chunks/framework.cb5c97e4.js";const f=JSON.parse('{"title":"一小时读完《Vue.js 设计与实现》","description":"","frontmatter":{},"headers":[],"relativePath":"VueStudy/Vue.js 设计与实现.md","filePath":"VueStudy/Vue.js 设计与实现.md"}'),t={name:"VueStudy/Vue.js 设计与实现.md"},r=d('<h1 id="一小时读完《vue-js-设计与实现》" tabindex="-1">一小时读完《Vue.js 设计与实现》 <a class="header-anchor" href="#一小时读完《vue-js-设计与实现》" aria-label="Permalink to &quot;一小时读完《Vue.js 设计与实现》&quot;">​</a></h1><h2 id="序" tabindex="-1">序 <a class="header-anchor" href="#序" aria-label="Permalink to &quot;序&quot;">​</a></h2><p>这是一本没有带你阅读一行源码，却可以让你在阅读完成之后，对 <code>vue 3</code> 所有的核心逻辑 <strong>了如指掌</strong> 的书籍。</p><p>无论是 <strong>响应性、调度系统、惰性执行</strong> ，还是 **渲染器、diff 算法、编辑器三大步 ** ，甚至是 <strong>有限自动状态机</strong> 等所有你能想到知识，本书都可以给你答案。</p><p>它就是 <strong>尤雨溪亲自做序</strong> ，<strong>Vue 官方团队成员：霍春阳</strong> 编写的 <strong>Vue.js 设计与实现</strong>。</p><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p><code>hello</code>，各位小伙伴，大家好。我是 <code>Sunday</code>。</p><p>在当前这个时间段下，关于 <code>vue 3</code> 源码的书籍，主要有两本。</p><p>第一本就是，咱们本次要讲的 <strong>《Vue.js 设计与实现》</strong>。</p><p>第二本是，<strong>《vue.js 技术内幕》</strong>，作者是黄轶。</p><p>正巧，两本书我都买来了。</p><p>这两本书，虽然都是讲解 <code>vue 3</code> 源码的，但是在讲解的方式上，有非常大的区别。</p><p>首先是 《Vue.js 设计与实现》：它不同于市场上纯粹的 “源码分析” 类的书籍。而是 <strong>从高层的设计角度，探讨框架需要关注的问题（-尤雨溪序）</strong>，以 <strong>提出问题 - 分析思路 - 解决问题</strong> 的方式，来讲解 <code>vue 3</code> 的核心设计。其内部，没有读一行 <code>vue3</code> 的源码，但却可以让我们对整个 <code>vue 3</code> 的核心，拥有一个非常清楚的认知。</p><p>其次是 《vue.js 技术内幕》：它是一个标准的 “源码分析” 书籍，内部对 <code>vue 3</code> 的很多源码，进行了逐一的解读。</p><p>如果大家想要学习 <code>vue 3</code> 的设计思路，掌握框架设计的思维方式。那么我强烈推荐你看一看《Vue.js 设计与实现》。</p><p>如果你想要对 <code>vue</code> 源码进行逐一解读，那么可以看一下《vue.js 技术内幕》。</p><p><s>同时，最后请允许我打一个小广告，如果你不想看书，想要通过视频的方式学习 <code>vue 3</code> 核心逻辑，可以去看一下我在 慕课网的 <a href="https://coding.imooc.com/class/608.html" target="_blank" rel="noreferrer">Vue3源码解析，打造自己的Vue3框架</a> 这门课程。我个人 <strong>强烈推荐</strong> ！</s></p><p>那么明确好了现在市面上学习 <code>vue 3</code> 源码的方式之后，下面就让我们进入到 《Vue.js 设计与实现》的学习中去吧！</p><h2 id="大纲" tabindex="-1">大纲 <a class="header-anchor" href="#大纲" aria-label="Permalink to &quot;大纲&quot;">​</a></h2><p>《Vue.js 设计与实现》的内容一共分为 6 篇， <code>18</code> 个章节：</p><ul><li>首先第一篇：对 <code>vue</code> 的整个框架设计，进行了概述</li><li>第二篇：主要讲解了 <code>vue</code> 中的响应式系统，除了大家所熟悉的 <code>proxy</code> 之外，额外还包含了：调度系统 <code>scheduler</code>、惰性执行 <code>lazy</code>、<code>ref</code> 的实现原理</li><li>第三篇：主要针对 <code>vue</code> 的渲染器（<code>renderer</code>）进行了讲解，额外还包含了 <code>diff</code> 算法的详细讲解</li><li>第四篇：是组件化。包含了 组件的渲染机制，以及对 <code>vue</code> 官方组件 <code>KeepAlive</code>、<code>Teleport</code>、<code>Transition</code> 的实现原理，进行了剖析</li><li>第五篇：是编译器（<code>compiler</code>）。在这一篇中，把编译器的三大步：<code>parse</code>、<code>transform</code>、<code>generate</code> 进行了分步的讲解。</li><li>最后：是服务端渲染。主要是 <code>CSR</code>、<code>SSR</code> 以及 同构渲染。</li></ul><h2 id="第一篇-框架设计概览" tabindex="-1">第一篇：框架设计概览 <a class="header-anchor" href="#第一篇-框架设计概览" aria-label="Permalink to &quot;第一篇：框架设计概览&quot;">​</a></h2><p>整个第一篇分为三个章节：</p><ol><li>权衡的艺术：这里主要涉及到了 <code>vue</code> 框架设计的一些基本概念，也是咱们讲解的重点</li><li>框架设计的核心要素：相对比较杂，都是一些零碎的知识点</li><li>Vue.js 3 的设计思路：这一章包含了 <code>vue</code> 框架设计的逻辑主线，也非常重要，但是内容并不多</li></ol><p>那么首先咱们先来看第一章。</p><h3 id="第一章-权衡的艺术" tabindex="-1">第一章：权衡的艺术 <a class="header-anchor" href="#第一章-权衡的艺术" aria-label="Permalink to &quot;第一章：权衡的艺术&quot;">​</a></h3><p>在这一章中，开头的一句话，描述了框架设计的精髓，这句话也是尤雨溪在多个开发者大会中经常提到的，那就是：<strong>框架的设计，本身就是一种权衡的艺术</strong>。</p><p>在这一章中，书中分别从三个方面来去分析了所谓权衡的艺术，到底是什么意思。</p><h4 id="命令式和声明式" tabindex="-1">命令式和声明式 <a class="header-anchor" href="#命令式和声明式" aria-label="Permalink to &quot;命令式和声明式&quot;">​</a></h4><p>首先第一个方面就是：<strong>命令式和声明式</strong> 的概念。</p><p>所谓 <strong>命令式</strong> 指的就是：<strong>关注过程</strong> 的范式。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a18c4426c154e9a860ba9aafa683827~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230207231540415.png"></p><p>而 <strong>声明式</strong> 指的就是： <strong>关注结果</strong> 的范式。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd8c4bd0f4ff43f6b28c3249d1fd1b29~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230207231536123.png"></p><p>什么意思呢？我们来举一个小例子：</p><blockquote><p>张三的妈妈，让张三去买酱油。</p><p>那么对于张三而言，他就需要：拿钱、出门、下楼、进超市、拿酱油、付钱、回家。</p><p>而对于张三的妈妈来说，她完全不需要关心张三做了什么，只需要对张三说一声就可以了。</p></blockquote><p>那么在这个例子中，张三就是一个典型的命令式，他需要完成整件事情的所有过程。</p><p>而张三的妈妈，就是典型的声明式，她不关心过程只关心结果。</p><p>那么这里大家来想一下，<code>vue</code> 是声明式的？还是命令式的？</p><p>对于 <code>vue</code> 而言，它的内部实现一定是 <strong>命令式</strong> 的，而我们在使用 <code>vue</code> 的时候，则是通过 <strong>声明式</strong> 来使用的。</p><p>也就是说： <strong>vue 封装了命令式的过程，对外暴露出了声明式的结果</strong></p><h4 id="性能与可维护性的权衡" tabindex="-1">性能与可维护性的权衡 <a class="header-anchor" href="#性能与可维护性的权衡" aria-label="Permalink to &quot;性能与可维护性的权衡&quot;">​</a></h4><p>在明确好了命令式和声明式的概念之后。接下来咱们来看下从 <strong>性能</strong> 层面，<code>vue</code> 所体现出来的一种权衡的方式。</p><p>针对于性能的分析，主要从两个方面去说。</p><p>首先第一个方面：大家觉得 <strong>是命令式的性能更强，还是声明式的性能更强呢？</strong></p><p>答案是：<strong>命令式的性能 &gt; 声明式的性能</strong>。</p><p>其实原因非常简单，对于 <strong>命令式</strong> 的代码而言，它直接通过 <strong>原生的 <code>JavaScript</code> 进行实现</strong>，这是最简单的代码，没有比这个更简单的了，我们把它的性能比作 <code>1</code>。</p><p>而声明式，无论内部做了什么，它想要实现同样的功能，内部必然要实现同样的命令式代码。所以它的性能消耗一定是 <code>1 + N</code> 的。</p><p>那么既然如此，<code>vue</code> 为什么还要对外暴露出声明式的接口呢？</p><p>这其实是因为：<strong>声明式的可维护性，要远远大于命令式的可维护性</strong>。</p><blockquote><p>大家从这两段代码（命令式和声明式代码）中就可以发现，声明式代码比命令式代码要简单的多。</p><p>越简单的代码，可维护性就越强</p></blockquote><p>当性能与可维护性产生冲突时，那么舍鱼而取熊掌者也。（注意：在 <code>vue</code> 的性能优化之下，它并不会比纯命令式的性能差太多）</p><p>而这样的一种权衡，在 <code>template</code> 模板中，更是体现的淋漓尽致。</p><p>在前端领域，想要使用 <code>JavaScript</code> 修改 <code>html</code> 的方式，主要有三种：<strong><code>原生 JavaScript、innerHTML、虚拟 DOM</code></strong></p><p>很多小伙伴都会认为 <code>虚拟 DOM</code> 的性能是最高的，其实不是。</p><p>我们来看这个对比。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1055adc3787b4c0a80fcbc9f9eab4df8~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230207233547097.png"></p><p>从这个对比我们可以发现，<code>虚拟 DOM</code> 的性能，并不是最高的。</p><p>但是它的 <strong>心智负担（书写难度）最小</strong>， 从而带来了 <strong>可维护性最高</strong>。所以哪怕它的性能并不是最高的。<code>vue</code> 依然选择了 <code>虚拟 DOM</code> 来进行了渲染层的构建。</p><p>这个也是一种性能与可维护性的权衡。</p><h4 id="运行时和编译时" tabindex="-1">运行时和编译时 <a class="header-anchor" href="#运行时和编译时" aria-label="Permalink to &quot;运行时和编译时&quot;">​</a></h4><p>第一章的最后一部分，主要讲解的就是 <strong>运行时和编译时</strong>。</p><p>这两个名词，各位小伙伴在日常开发中，应该是经常听到的。</p><p>它们两个都是框架设计的一种方式，可单独出现，也可组合使用。</p><p>那么下面咱们就分别来介绍一下它们。</p><p>首先是 <strong>运行时：<code>runtime</code></strong>。</p><blockquote><p>它指的是：<strong>利用 render 函数，直接把 虚拟 <code>DOM</code> 转化为 真实 <code>DOM</code> 元素</strong> 的一种方式。</p><p>在整个过程中，不包含编译的过程，所以无法分析用户提供的内容。</p></blockquote><p>其次是 <strong>编译时：compiler</strong>：</p><blockquote><p>它指的是：<strong>直接把 <code>template</code> 模板中的内容，转化为 真实 <code>DOM</code> 元素</strong>。</p><p>因为存在编译的过程，所以可以分析用户提供的内容。</p><p>同时，没有运行时理论上性能会更好。</p><p>目前该方式，有具体的实现库，那就是现在也非常火的 <code>Svelte</code></p><p>但是这里要注意： <strong>它的真实性能，没有办法达到理论数据。</strong></p></blockquote><p>最后是 <strong>运行时 + 编译时</strong>：</p><blockquote><p>它的过程被分为两步：</p><ol><li>先把 <code>template</code> 模板转化为 <code>render</code> 函数。也就是 <strong>编译时</strong></li><li>再利用 <code>render</code> 函数，把 虚拟 <code>DOM</code> 转化为 真实 <code>DOM</code>。也就是 <strong>运行时</strong></li></ol><p>两者的结合，可以：</p><p>在 编译时，分析用户提供的内容 在 运行时，提供足够的灵活性</p><p>这也是 <code>vue</code> 的主要实现方式。</p></blockquote><h3 id="第二章-框架设计的核心要素" tabindex="-1">第二章：框架设计的核心要素 <a class="header-anchor" href="#第二章-框架设计的核心要素" aria-label="Permalink to &quot;第二章：框架设计的核心要素&quot;">​</a></h3><p>这一章主要讲解了，框架设计时一些凌乱的注意点。</p><p>比如：</p><ol><li>通过 环境变量 和 <code>TreeShanking</code> 控制打包之后的体积</li><li>构建不同的打包产物，以应用不同的场景</li><li>提供了 <code>callWithErrorHandling</code> 接口函数，来对错误进行统一处理</li><li>源码通过 <code>TypeScript</code> 开发，以保证可维护性。</li><li>内部添加了大量的类型判断和其他工作，以保证开发者使用时的良好体验。</li></ol><p>这些东西都是基于一个个的小点单独去说的，整体之间并没有一个完成的线性逻辑。</p><p>所以大家可以根据具体感兴趣或者不了解的点，单独去看就可以。</p><h3 id="第三章-vue-js-3-的设计思路" tabindex="-1">第三章：Vue.js 3 的设计思路 <a class="header-anchor" href="#第三章-vue-js-3-的设计思路" aria-label="Permalink to &quot;第三章：Vue.js 3 的设计思路&quot;">​</a></h3><p>在这一章中，作者站在一个高层的角度，以 <strong><code>UI</code> 形式、渲染器、组件、编辑器</strong> 为逻辑主线进行的讲解。</p><p>下面咱们就来捋一捋这条线。</p><p>在 <code>Vue</code> 中 <code>UI</code> 形式主要分为两种：</p><ul><li>声明式的模板描述</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/204d3c7bd04f44b3be8eed7ebb8441a7~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230208170232727.png"></p><ul><li>命令式的 render 函数</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f6d472daf6d4a7db97f39f655787ba1~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230208170236795.png"></p><p>而针对于 <strong>声明式的模板描述</strong> 而言，本质上就是咱们常用的 <code>tempalte</code> 模板。它会被 <strong>编辑器</strong> 编译，得到 <strong>渲染函数 <code>render</code></strong> 。</p><p>渲染器与渲染函数，并 <strong>不是</strong> 一个东西。</p><p>渲染器是 <strong>函数 <code>createRenderer</code> 的返回值，是一个对象。被叫做 <code>renderer</code></strong>。 <strong><code>renderer</code> 对象中有一个方法 <code>render</code></strong>，这个 <code>render</code> ，就是我们常说的<strong>渲染函数</strong>。</p><p>渲染函数接收两个参数 <code>VNode</code> 和 <code>container</code>。</p><p>其中 <code>VNode</code> 表示 <strong>虚拟 DOM</strong>，本质上是一个 <code>JS</code> 对象。<code>container</code> 是一个容器，表示被挂载的位置。而 <code>render</code> 函数的作用，就是： <strong>把 <code>vnode</code> 挂载到 <code>container</code> 上</strong>。</p><p>同时，因为 <code>Vue</code> 以组件代表最小颗粒度，所以 <code>vue</code> 内部的渲染，本质上是：<strong>大量的组件渲染</strong>。</p><p>而组件本质上是一组 <code>DOM</code> 的集合，所以渲染一个一个的组件，本质上就是在渲染一组这一组的 <code>DOM</code>。也就是说，<code>Vue</code> 本质上是： <strong>以组件作为介质，来完成针对于一组、一组的 <code>DOM</code> 渲染。</strong></p><h3 id="第一篇总结" tabindex="-1">第一篇总结 <a class="header-anchor" href="#第一篇总结" aria-label="Permalink to &quot;第一篇总结&quot;">​</a></h3><p>在整个第一篇中，作者主要就是通过这三章的内容， <strong>自顶向下</strong> 的为我们介绍了 <code>vue</code> 的框架设计逻辑。其目的主要就是为了让我们了解， <code>Vue</code> 框架的运行逻辑和一些关键概念。</p><h2 id="第二篇-响应式系统" tabindex="-1">第二篇：响应式系统 <a class="header-anchor" href="#第二篇-响应式系统" aria-label="Permalink to &quot;第二篇：响应式系统&quot;">​</a></h2><p>第二篇主要是针对 <strong>响应式系统</strong> 的讲解。</p><p>同样也是被分为三章：</p><ul><li>首先第一章，也是最重要的一章，就是 <strong>响应系统的作用与实现</strong></li><li>第二章，主要针对 <strong>对象的响应性实现原理</strong> 进行了讲解</li><li>第三章，主要针对 <strong>非对象的响应性实现原理</strong> 进行了讲解</li></ul><h3 id="第四章-响应系统的作用与实现" tabindex="-1">第四章：响应系统的作用与实现 <a class="header-anchor" href="#第四章-响应系统的作用与实现" aria-label="Permalink to &quot;第四章：响应系统的作用与实现&quot;">​</a></h3><p>在这一章中，作者从 <strong>响应式数据的概念开始，讲解了响应式系统的实现。</strong> 然后针对于 <strong>计算属性与 <code>watch</code> 的实现原理，进行了分析。</strong> 在分析的过程中，也对其所设计到的 <strong><code>调度系统（scheduler）</code> 和 <code>惰性执行（lazy）</code> 的原理进行了明确。</strong> 最后讲解了在 <strong>竞态问题下，关于过期的副作用的处理逻辑。</strong></p><h4 id="响应式数据" tabindex="-1">响应式数据 <a class="header-anchor" href="#响应式数据" aria-label="Permalink to &quot;响应式数据&quot;">​</a></h4><p>那么首先咱们先来看基本概念 <strong>副作用函数 与 响应式数据</strong>。</p><p>所谓 <strong>副作用函数</strong> 指的是 <strong>会产生副作用的函数</strong>，这样的函数非常的多。比如</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef34b738308e460280f9cd8120dc1c4e~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230208190429676.png"></p><p>在这段代码中， <code>effect</code> 的触发会导致全局变化 <code>val</code> 发生变化，那么 <code>effect</code> 就可以被叫做<strong>副作用函数</strong>。而如果 <code>val</code> 这个数据的变化，导致了视图的变化，那么 <code>val</code> 就被叫做 <strong>响应式数据</strong>。</p><p>那么如果想要实现响应式数据的话，那么它的核心逻辑，必然要依赖两个行为：</p><ul><li>第一个是 <code>getter</code> 行为，也就是 <strong>数据读取</strong></li><li>第二个是 <code>setter</code> 行为，也就是 <strong>数据修改</strong></li></ul><p>在 <code>vue 2</code> 中，这样的两个行为通过 <code>Object.defineProperty</code> 进行的实现。</p><p>在 <code>vue 3</code> 中，这样的两个行为通过 <code>Proxy</code> 进行的实现。</p><p>那么具体的实现逻辑是什么呢？咱们来看下面的图示：</p><blockquote><p>首先是 <code>getter</code> 形式：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82855905c19c4f309d9f4253575c80ca~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230208191120105.png"></p><p>在该函数中，存在一个 <code>effect</code> 方法，方法内部触发了 <code>getter</code> 行为。一旦 <code>getter</code> 行为被触发，则把对应的 <code>effect</code> 方法保存到一个 “桶（数据对象）” 中</p><p>当触发 <code>setter</code> 行为时：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ef91f7616374f0db7f9f14b3674382b~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230208191257788.png"></p><p>则会从 “桶” 中取出 <code>effect</code> 方法，并执行。</p><p>那么此时因为 <code>obj.text</code> 的值发生了变化，所以 <code>effect</code> 被执行时 <code>document.body.innerText</code> 会被赋上新的值。从而导致视图发生变化。</p></blockquote><p>这是一套构建响应式系统的基础逻辑。这一套逻辑足够应对大家在日常的 <strong>面试</strong> 或者 <strong>工作</strong> 中的基本需求。</p><p>而这套逻辑说起来简单，做起来还是有一些难度的。如果想要构建出一套完善的响应式系统，那么需要做非常多的工作，篇幅也会非常长。这就不是咱们这一个视频的长度可以解决的了。</p><p>所以我在这里给大家提供了两个方案，第一个是：我在掘金上发布的博客《手写响应式模块》。第二个是：我在慕课网的视频《Vue 3 源码解析，打造自己的 vue 框架》，里面也详细的讲解并且实现了响应性模块。大家可以按需进行选择。</p><h4 id="调度系统-scheduler" tabindex="-1">调度系统（scheduler） <a class="header-anchor" href="#调度系统-scheduler" aria-label="Permalink to &quot;调度系统（scheduler）&quot;">​</a></h4><p>那么说完了基本的响应性之后，接下来咱们来看 <strong>调度系统（<code>scheduler</code>）</strong></p><p>所谓调度系统，指的就是 <strong>响应性的可调度性</strong>。</p><p>而所谓的可调度，指的就是 <strong>当数据更新的动作，触发副作用函数重新执行时，有能力决定：副作用函数（effect）执行的时机、次数以及方式</strong></p><p>比如，在这段打印中，决定打印的顺序</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f526a19532b4b6391fef8856d6cd6b6~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230208192343242.png"></p><p>而想要实现一个调度系统，则需要依赖 <strong><code>异步：Promise</code> 和 <code>队列：jobQueue</code></strong> 来进行实现。咱们需要 <strong>基于 <code>Set</code> 构建出一个基本的队列数组 <code>jobQueue</code>，利用 <code>Promise</code> 的异步特性，来控制执行的顺序</strong></p><h4 id="计算属性-computed" tabindex="-1">计算属性（computed） <a class="header-anchor" href="#计算属性-computed" aria-label="Permalink to &quot;计算属性（computed）&quot;">​</a></h4><p>当我们可以控制了执行顺序之后，那么就可以利用这个特性来完成 <strong>计算属性（computed）</strong> 的实现了。</p><p>计算属性本质上是： <strong>一个属性值，当依赖的响应式数据发生变化时，重新计算</strong></p><p>那么它的实现就需要彻底依赖于 <strong>调度系统（scheduler）</strong> 来进行实现。</p><h4 id="惰性执行-lazy" tabindex="-1">惰性执行（lazy） <a class="header-anchor" href="#惰性执行-lazy" aria-label="Permalink to &quot;惰性执行（lazy）&quot;">​</a></h4><p>说完计算属性，那么下面我们来看下 <code>watch</code> 监听器。</p><p><code>watch</code> 监听器本质上是 <strong>观测一个响应式数据，当数据发生变化时，通知并执行相应的回调函数</strong></p><p>这也就意味着，<code>watch</code> 很多时候并不需要立刻执行。</p><p>那么此时，就需要使用到 <strong>惰性执行（<code>lazy</code>）</strong> 来进行控制。</p><p>惰性执行的实现要比调度系统简单。它本质上 <strong>是一个 <code>boolean</code> 型的值，可以被添加到 <code>effect</code> 函数中，用来控制副作用的执行</strong>。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> (</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">lazy) </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 执行副作用函数</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="watch-的实现原理" tabindex="-1">watch 的实现原理 <a class="header-anchor" href="#watch-的实现原理" aria-label="Permalink to &quot;watch 的实现原理&quot;">​</a></h4><p>基于 调度系统 与 惰性执行，那么就可以实现 <code>watch</code> 监听器了。</p><h4 id="过期的副作用" tabindex="-1">过期的副作用 <a class="header-anchor" href="#过期的副作用" aria-label="Permalink to &quot;过期的副作用&quot;">​</a></h4><p><code>watch</code> 监听器的实现非常广泛，有时候我们甚至可以在 <strong><code>watch</code> 中完成一些异步操作。</strong></p><p>但是大量的异步操作，极有可能会导致 <strong>竞态问题</strong>。</p><p>所谓的竞态问题，指的是 <strong>在描述一个系统或者进程的输出，依赖于不受控制的事件出现顺序或者出现时机</strong>。比如咱们来看这段代码</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec32164f3399416c9f9ffbdb3a7c471b~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230208194352049.png"></p><blockquote><p>这段代码完成的是一个异步操作。</p><p>如果 <code>obj</code> 连续被修改了两次，那么就会发起两个请求。我们最终的期望应该是 <code>data</code> 被赋值为 请求B 的结果。</p><p>但是，因为异步的返回结果我们无法预计。所以，如果 请求 B 先返回，那么最终 <code>data</code> 的值就会变为 请求 A 的返回值。</p><p>这个咱们的期望是不一样的。</p><p>那么这样的问题，就是 <strong>竞态问题</strong></p></blockquote><p>而如果想要解决这问题，那么就需要使用到 <code>watch</code> 回调函数的第三个参数 <code>onInvalidate</code>，它本身也是一个回调函数。并且 <strong>该回调函数（<code>onInvalidate</code>）会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求</strong></p><p>而 <code>onInvalidate</code> 的实现原理也非常简单，只需要 <strong>在副作用函数（effct）重新执行前，先触发 <code>onInvalidate</code></strong> 即可。</p><h4 id="第四章总结" tabindex="-1">第四章总结 <a class="header-anchor" href="#第四章总结" aria-label="Permalink to &quot;第四章总结&quot;">​</a></h4><p>那么到这里，咱们就把 <strong>响应性系统的大致核心逻辑</strong> 明确完成了。从这个逻辑中，我们知道想要实现响应性数据，那么核心就是通过 <code>Proxy</code> 实现。</p><p>那么这个 <code>proxy</code> 具体怎么做呢？</p><p>接下来，咱们来看第五章。</p><h3 id="第五章-非原始值-对象-的响应性方案" tabindex="-1">第五章：非原始值（对象）的响应性方案 <a class="header-anchor" href="#第五章-非原始值-对象-的响应性方案" aria-label="Permalink to &quot;第五章：非原始值（对象）的响应性方案&quot;">​</a></h3><p>书中的第五章整体而言非常简单，主要就介绍了两个接口，<code>Proxy</code> 和 <code>Reflect</code>。</p><p>这两个接口通常会一起进行使用，其中：</p><ul><li><code>Proxy</code> 可以 <strong>代理一个对象（被代理对象）的 getter 和 setter 行为，得到一个 proxy 实例（代理对象）</strong></li><li><code>Reflect</code> 可以 <strong>在 Proxy 中使用 this 时，保证 this 指向 proxy，从而正确执行次数的副作用</strong></li></ul><h3 id="第六章-原始值-非对象-的响应性方案" tabindex="-1">第六章：原始值（非对象）的响应性方案 <a class="header-anchor" href="#第六章-原始值-非对象-的响应性方案" aria-label="Permalink to &quot;第六章：原始值（非对象）的响应性方案&quot;">​</a></h3><p>如果大家熟悉 <code>proxy</code> 的话，那么可以知道，针对于 <code>proxy</code> 而言，它只能代理复杂数据类型。这就意味着，简单数据类型无法具备响应性。</p><p>但是，在 <code>vue</code> 中，我们可以通过 <code>ref</code> 构建简单数据类型的响应。</p><p>那么 <code>ref</code> 是如何进行实现的呢？</p><p>这里大家要注意：<strong>针对于最新的 vue 3.2 而言，书中在 《6.1 引入 ref 的概念》中所讲解的 ref 实现原理存在 “落后性”。 vue 3.2 已经修改了 ref 的实现，这得益于 @basvanmeurs 的贡献</strong></p><p>在最新的 <code>vue 3.2</code> 代码中，<code>vue</code> 通过 **<code>get</code> 、<code>set</code> 函数标记符，让函数以属性调用的形式被触发。**这两个修饰符，可以让我们 <strong>像调用属性一样，调用方法</strong>。 所以当我们平时 <strong>访问 ref.value 属性时，本质上是 value() 函数的执行</strong>。</p><h3 id="第二篇总结" tabindex="-1">第二篇总结 <a class="header-anchor" href="#第二篇总结" aria-label="Permalink to &quot;第二篇总结&quot;">​</a></h3><p>那么到这里咱们整个响应式系统的大概流程，就已经描述完成了。其核心逻辑主要就是在第四章中。</p><p>至于第五章和第六章，更多的偏向于具体的细节和代码逻辑。</p><h2 id="第三篇-渲染器" tabindex="-1">第三篇：渲染器 <a class="header-anchor" href="#第三篇-渲染器" aria-label="Permalink to &quot;第三篇：渲染器&quot;">​</a></h2><p>那么下面咱们来看 <strong>第三篇：渲染器</strong> 。</p><p>第三篇一共被分为 5 个章节。但是只讲解了三部分内容。</p><ul><li>首先第七章，主要讲解了<strong>渲染器的设计</strong>。</li><li>第八章，主要讲解了 <strong><code>DOM</code> 的挂载和更新的逻辑</strong>。</li><li>而 第九、十、十一 这三章，主要讲解了 <strong>Diff 算法</strong></li></ul><h3 id="第七章-渲染器的设计" tabindex="-1">第七章：渲染器的设计 <a class="header-anchor" href="#第七章-渲染器的设计" aria-label="Permalink to &quot;第七章：渲染器的设计&quot;">​</a></h3><p>在之前咱们说过 <strong>渲染器与渲染函数不是一个东西</strong></p><ul><li><strong>渲染器</strong> 是 <code>createRenderer</code> 的返回值，是一个对象。</li><li><strong>渲染函数</strong> 是渲染器对象中的 <code>render</code> 方法</li></ul><p>在 <code>vue 3.2.37</code> 的源码内部，<code>createRenderer</code> 函数的具体实现是通过 <code>baseCreateRenderer</code> 进行的。它的代码量非常庞大，涉及到了 <code>2000</code> 多行的代码。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab42acdff39a482fb65bc4f72fa00301~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230209085155034.png"></p><p>代码量虽多，但是核心思路并不是特别复杂。总体可以被分为两部分：</p><ol><li><strong>在浏览器端渲染时，利用 <code>DOM API</code> 完成 <code>DOM</code> 操作</strong>：比如，如果渲染 <code>DOM</code> 那么就使用 <code>createElement</code>，如果要删除 <code>DOM</code> 那么就使用 <code>removeChild</code>。</li><li><strong>渲染器不能与宿主环境（浏览器）产生强耦合</strong>：因为 <code>vue</code> 不光有浏览器渲染，还包括了 <code>服务端</code> 渲染，所以如果在渲染器中绑定了宿主环境，那么就不好实现服务端渲染了。</li></ol><p>在渲染的过程中，还有一个非常重要的概念 <code>vnode</code>。书中并没有专门的章节来介绍 <code>vnode</code>。所以为了避免各位小伙伴对 <code>vnode</code> 不了解，咱们单独把 <code>vnode</code> 说一下。</p><p>所谓 <code>vnode</code> 本身是 <strong>一个普通的 JavaScript 对象，代表了渲染的内容</strong>。对象中通过 <code>type</code> 表示渲染的 <code>DOM</code>。比如 <code>type === div</code>：则表示 <code>div</code> 标签、<code>type === Framgnet</code> 则表示渲染片段（vue 3 新增）、<code>type === Text</code> 则表示渲染文本节点。</p><h3 id="第八章-挂载与更新" tabindex="-1">第八章：挂载与更新 <a class="header-anchor" href="#第八章-挂载与更新" aria-label="Permalink to &quot;第八章：挂载与更新&quot;">​</a></h3><p>对于渲染器而言，它做的最核心的事情就是 <strong>对节点进行挂载、更新的操作</strong>。作者在第八章中，详细的介绍了对应的逻辑。</p><p>整个第八章分为两部分来讲解了这个事情：</p><ol><li><code>DOM</code> 节点操作</li><li>属性节点操作</li></ol><h4 id="dom-节点操作" tabindex="-1"><code>DOM</code> 节点操作 <a class="header-anchor" href="#dom-节点操作" aria-label="Permalink to &quot;`DOM` 节点操作&quot;">​</a></h4><p>首先先来看 <code>DOM</code> 节点操作。<code>DOM</code> 节点的操作可以分为三部分：</p><ul><li><strong>挂载</strong>：所谓挂载表示节点的初次渲染。比如，可以直接通过 <code>createElement</code> 方法新建一个 <code>DOM</code> 节点，再利用 <code>parentEl.insertBefore </code> 方法插入节点。</li><li><strong>更新</strong>：当响应性数据发生变化时，可能会涉及到 <code>DOM</code> 的更新。此时的更新本质上是属于 <strong>属性的更新</strong>。咱们等到属性节点操作那里再去说。</li><li><strong>卸载</strong>：所谓卸载表示旧节点不在被需要了。那么此时就需要删除旧节点，比如可以通过 <code>parentEl.removeChild</code> 进行。</li></ul><p>以上三种类型，是 <code>vue</code> 在进行 <code>DOM</code> 操作时的常见逻辑。基本上覆盖了 <code>DOM</code> 操作 <code>90% 以上</code> 的常见场景</p><h4 id="属性节点操作" tabindex="-1">属性节点操作 <a class="header-anchor" href="#属性节点操作" aria-label="Permalink to &quot;属性节点操作&quot;">​</a></h4><p>看完了 <code>DOM</code> 操作之后，接下来咱们来看属性节点操作。</p><p>针对于属性而言，大体可以分为两类：</p><ol><li><strong>属性</strong>：比如 <code>class</code>、<code>id</code>、<code>value</code>、<code>src</code>...</li><li><strong>事件</strong>：比如 <code>click</code>、<code>input</code>....</li></ol><p>那么咱们就先来看 <strong>非事件的属性部分</strong>。</p><p>想要了解 <code>vue</code> 中对于属性的处理，那么首先咱们需要先搞明白一个很重要的问题。那就是 <strong>浏览器中的属性分类</strong>。</p><p>在浏览器中 <code>DOM</code> 属性其实被分为了两类：</p><ul><li>第一类叫做 <code>HTML Attributes</code>：直接定义在 <code>HTML 标签</code> 上的属性，都属于这一类。</li><li>第二类叫做 <code>DOM Properties</code>：它是拿到 <code>DOM</code> 对象后定义的属性。咱们接下来主要要说的就是它。</li></ul><p><code>HTML Attributes</code> 的定义相对而言比较简单和直观，但是问题在于 <strong>它只能在 <code>html</code> 中进行操作</strong>。</p><p>而如果想要在 <code>JS</code> 中操作 <code>DOM</code> 属性，就必须要通过 <code>DOM Properties</code> 来进行实现。但是因为 <code>JS</code> 本身特性的问题，会导致某些 <code>DOM Properties</code> 的设置存在特殊性。比如 <code>class、type、value</code> 这三个。</p><p>所以为了保证 <code>DOM Properties</code> 的成功设置，那么我们就必须要知道 **不同属性的 <code>DOM Properties</code> 定义方式 **。</p><p>下面咱们来看一下。</p><p><code>DOM Properties</code> 的设置一共被分为两种：</p><ol><li><code>el.setAttribute(&#39;属性名&#39;, &#39;属性值&#39;)</code></li><li><code> . 属性赋值</code> ： <code>el.属性名 = 属性值</code> 或者 <code>el[属性名] = 属性值</code> 都属于 <code>.属性赋值</code></li></ol><p>我们来看这段代码：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/100aef93baa14a6e9c7e9c493a380611~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230209093545078.png"></p><blockquote><p>在这段代码中，我们为 <code>textarea</code> 利用 <code>DOM Properties</code> 的方式设置了三个不同的属性：</p><ul><li>首先是 <code>class</code>： <code>class</code> 在属性操作中是一个非常特殊的存在。它有两个名字 <code>class</code> 和 <code>className</code>。如果我们直接通过 <code>el.setAttribute</code> 的话，那么必须要用 <code>class</code> 才可以成功，而如果是通过 <code>. 属性</code> 的形式，那么必须要使用 <code>className</code> 才可以成功。</li><li>第二个是 <code>type</code>： <code>type</code> 仅支持 <code>el.setAttribute</code> 的方式，不支持 <code>.属性的方式</code></li><li>第三个是 <code>value</code>：<code>value</code> 不支持直接使用 <code>el.setAttribute</code> 设置，但是支持 <code>.属性</code> 的设置方式</li></ul></blockquote><p>除了这三个属性之外，其实还有一些其他的属性也需要进行特殊处理，咱们这里就不再一一赘述了。</p><h4 id="事件" tabindex="-1">事件 <a class="header-anchor" href="#事件" aria-label="Permalink to &quot;事件&quot;">​</a></h4><p>接下来，咱们来看 <code>vue</code> 对事件的处理操作。</p><p>事件的处理和属性、<code>DOM</code> 一样，也是分为 <strong>添加、删除、更新</strong> 三类。</p><ul><li>添加：添加比较简单，主要利用 <code>el.addEventListener</code> 进行实现即可。</li><li>删除：主要利用 <code>el.removeEventListener</code> 进行处理。</li><li>更新：但是对于更新来说，就比较有意思了。下面咱们主要来看的就是这个更新操作。</li></ul><p>通常情况下，我们所认知的事件更新应该是 <strong>删除旧事件、添加新事件</strong> 的过程。但是如果利用 <code>el.addEventListener</code> 和 <code>el.removeEventListener</code> 来完成这件事情，是一件非常消耗性能的事。</p><p>那么怎么能够节省性能，同时完成事件的更新呢？</p><p>这时，<code>vue</code> 对事件的更新提出了一个叫做 <code>vei</code> 的概念，这个概念的意思是： <strong>为 <code>addEventListener</code> 回调函数，设置了一个 <code>value</code> 的属性方法，在回调函数中触发这个方法。通过更新该属性方法的形式，达到更新事件的目的。</strong></p><p>这个代码比较多，大家如果想要查看具体代码的话，可以 <a href="https://github.com/lgd8981289/vue-next-mini" target="_blank" rel="noreferrer">在 github 搜索 vue-next-mini</a>，进入到 <code>packages/runtime-dom/src/modules/events.ts</code> 路径下查看。</p><h3 id="第九、十、十一章-diff-算法" tabindex="-1">第九、十、十一章：Diff 算法 <a class="header-anchor" href="#第九、十、十一章-diff-算法" aria-label="Permalink to &quot;第九、十、十一章：Diff 算法&quot;">​</a></h3><p>整个渲染器最后的三个章节全部都用来讲解了 <code>diff</code> 算法。</p><p>针对于 <code>diff</code> 而言，它的本质其实就是一个对比的方法，其描述的核心就是： <strong>“旧 DOM 组”更新为“新 DOM 组”时，如何更新才能效率更高。</strong></p><p>目前针对于 <code>vue 3.2.37</code> 的版本来说，整个的 <code>diff</code> 算法被分为 5 步（<strong>这 5 步不跟大家读了，因为咱们没头没尾的读一遍，其实对大家也没有什么帮助</strong>）：</p><ol><li><code>sync from start</code>：自前向后的对比</li><li><code>sync from end</code>：自后向前的对比</li><li><code> common sequence + mount</code>：新节点多于旧节点，需要挂载</li><li><code>common sequence + unmount</code>：旧节点多于新节点，需要卸载</li><li><code>unknown sequence</code>：乱序</li></ol><p>而，针对于书中的这三章来说，本质上是按照 <strong>简单 diff 算法、双端 diff 算法、快速 diff 算法</strong> 的顺序把整个 <code>diff</code> 的前世今生基本上都说了一遍。里面涉及到了非常多的代码。</p><p>所以说咱们在当前的这个视频中，肯定是没有办法为大家讲解具体算法逻辑的。</p><p>针对于这一块，我同样也是准备了另外的博客和视频：</p><ul><li>首先是 <a href="https://juejin.cn/post/71907262420" target="_blank" rel="noreferrer">免费的博客版</a> ，我把它发布到了掘金。<strong>在评论区，会通过评论的形式为大家提供地址</strong>。</li><li>其次是 <a href="https://coding.imooc.com/class/608.htm" target="_blank" rel="noreferrer">收费的视频版</a>，是在慕课网发布的。<strong>同样链接会放到评论区</strong>。</li></ul><h3 id="第三篇总结" tabindex="-1">第三篇总结 <a class="header-anchor" href="#第三篇总结" aria-label="Permalink to &quot;第三篇总结&quot;">​</a></h3><p>针对于第三篇渲染器来说，咱们所描述的重点主要是围绕 <strong>渲染器的设计</strong> 和 <strong><code>DOM</code> 的挂载和更新的逻辑</strong> 来去说的。</p><p>针对于这两部分而言，大家要明确 <strong>渲染器与渲染函数的区别</strong>，同时要知道 <code>HTML Attributes</code> 和 <code>DOM Properties</code> 在行为上的差异性。另外关于事件更新的 <code>vei</code> 概念，应该也可以给大家带来一些新的思路。</p><p>而针对于 <code>diff</code>，咱们没有放在当前视频中去说，主要还是因为时长不够的原因。但是我为大家准备了额外的博客和视频，大家可以根据自己需要去进行查看。</p><h2 id="第四篇-组件化" tabindex="-1">第四篇：组件化 <a class="header-anchor" href="#第四篇-组件化" aria-label="Permalink to &quot;第四篇：组件化&quot;">​</a></h2><p>第四篇组件化，它应该算是比较简单的一个篇章，也是分为三部分来去讲解：</p><ol><li>组件的实现原理：这是咱们讲解的重心，但是不用担心，它并不复杂。</li><li>异步组件与函数式组件：这个比较冷僻，在实际开发中的使用场景有限</li><li>内建组件和模块：里面主要讲解了 <code>KeepAlive</code>、<code>Teleport</code>、<code>Transition</code> 这三个内置组件的实现逻辑</li></ol><h3 id="第十二章-组件的实现原理" tabindex="-1">第十二章：组件的实现原理 <a class="header-anchor" href="#第十二章-组件的实现原理" aria-label="Permalink to &quot;第十二章：组件的实现原理&quot;">​</a></h3><p>想要了解 <code>vue</code> 中组件的实现，那么首先我们需要知道什么是组件。</p><p>组件本质上就是一个 <code>JavaScript</code> 对象，比如，以下对象就是一个基本的组件</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f75a31d7872b49dd840005b3063ebace~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230209105953064.png"></p><p>而对于组件而言，同样需要使用 <code>vnode</code> 来进行表示，当 <code>vnode</code> 的 <code>type</code> 属性是一个 <strong>自定义对象</strong> 时，那么这个 <code>vnode</code> 就表示组件的 <code>vnode</code></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa1be66ad7c745ac992d6150330ce9e8~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230209110548502.png"></p><p>而组件的渲染，本质上是 <strong>组件包含的 <code>DOM</code> 的渲染。</strong> 对于组件而言，必然会包含一个 <code>render</code> 渲染函数。如果没有 <code>render</code> 函数，那么 <code>vue</code> 会把 <code>template</code> 模板编译为 <code>render</code> 函数。而组件渲染的内容，其实就是 <code>render</code> 函数返回的 <code>vnode</code>。具体的渲染逻辑，全部都通过渲染器执行。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc767638e42c4c599926acf54021fc66~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230209110919710.png"></p><p><code>vue 3</code> 之后提出了 <code>composition API</code>，<code>composition API</code> 包含一个入口函数，也就是 <code>setup</code> 函数。 <code>setup</code> 函数包含两种类型的返回值：</p><ol><li><strong>返回一个函数</strong>：当 <code>setup</code> 返回一个函数时，那么该函数会被作为 <code>render</code> 函数直接渲染。</li><li><strong>返回一个对象</strong>：当 <code>setup</code> 返回一个对象时，那么 <code>vue</code> 会直接把该对象的属性，作为 <code>render</code> 渲染时的依赖数据</li></ol><p>同时，对于组件来说还有一个 <strong>插槽</strong> 的概念。插槽的实现并不神奇。插槽本质上 <strong>是一段 <code>innerHTML</code> 的内容，在 <code>vnode</code> 中以 <code>children</code> 属性进行呈现</strong>。当插槽被渲染时，只需要渲染 <code>children</code> 即可。</p><p>对于组件来说，除了咱们常用的 <strong>对象组件</strong> 之外，<code>vue</code> 还提供了额外的两种组件，也就是 <strong>异步组件与函数式组件</strong>。</p><h3 id="第十三章-异步组件与函数式组件" tabindex="-1">第十三章：异步组件与函数式组件 <a class="header-anchor" href="#第十三章-异步组件与函数式组件" aria-label="Permalink to &quot;第十三章：异步组件与函数式组件&quot;">​</a></h3><p>所谓异步组件，指的是： <strong>异步加载的组件</strong> 。</p><p>比如服务端返回一个组件对象，那么我们也可以拿到该对象，直接进行渲染。</p><p>异步组件在 <strong>优化页面性能、拆包、服务端下发组件</strong> 时，会比较有用。</p><p>而对于 <strong>函数式组件</strong> 来说，相对就比较冷僻了。函数式组件指的是 <strong>没有状态的组件。本质上是一个函数，可以通过静态属性的形式添加 <code>props</code> 属性</strong> 。在实际开发中，并不常见。</p><h3 id="第十四章-内建组件和模块" tabindex="-1">第十四章：内建组件和模块 <a class="header-anchor" href="#第十四章-内建组件和模块" aria-label="Permalink to &quot;第十四章：内建组件和模块&quot;">​</a></h3><p>这一章中，主要描述了 <code>vue</code> 的三个内置组件。</p><h4 id="keepalive" tabindex="-1">keepAlive <a class="header-anchor" href="#keepalive" aria-label="Permalink to &quot;keepAlive&quot;">​</a></h4><p>首先第一个是 <code>KeepAlive</code>。</p><p>这是我们在日常开发中，非常常用的内置组件。它可以 <strong>缓存一个组件，避免该组件不断地销毁和创建</strong>。</p><p>看起来比较神奇，但是它的实现原理其实并不复杂，主要围绕着 <strong>组件卸载</strong> 和 <strong>组件挂载</strong> 两个方面：</p><ul><li><strong>组件卸载</strong>：当一个组件被卸载时，它并不被真正销毁，而是把组件保存在一个容器中</li><li><strong>组件挂载</strong>：因为组件被保存了。所以当这个组件需要被挂载时，就不需要在重新创建，而是直接从容器中获取即可。</li></ul><h4 id="teleport" tabindex="-1">Teleport <a class="header-anchor" href="#teleport" aria-label="Permalink to &quot;Teleport&quot;">​</a></h4><p><code>Teleport</code> 是 <code>vue 3</code> 新增的组件，作用是 <strong>将 <code>Teleport</code> 插槽的内容渲染到其他的位置</strong>。比如我们可以把 <code>dialog</code> 渲染到 <code>body</code> 根标签之下。</p><p>它的实现原理，主要也是分为两部分：</p><ol><li>把 Teleport 组件的渲染逻辑，从渲染器中抽离</li><li>在指定的位置进行独立渲染</li></ol><h4 id="transition" tabindex="-1">Transition <a class="header-anchor" href="#transition" aria-label="Permalink to &quot;Transition&quot;">​</a></h4><p><code>Transition</code> 是咱们常用的动画组件，作用是 <strong>实现动画逻辑</strong>。</p><p>其核心原理同样被总结为两点：</p><ol><li><code>DOM</code> 元素被挂载时，将动效附加到该 <code>DOM</code> 元素上</li><li><code>DOM</code> 元素被卸载时，等在 <code>DOM</code> 元素动效执行完成后，执行卸载 <code>DOM</code> 操作</li></ol><h3 id="第四篇总结" tabindex="-1">第四篇总结 <a class="header-anchor" href="#第四篇总结" aria-label="Permalink to &quot;第四篇总结&quot;">​</a></h3><p>整个第四篇，主要围绕着组件来去讲。所以内容并不复杂。</p><p>对于咱们的日常的开发与面试而言，其实只需要搞清楚 <strong>组件的原理</strong> 与 <strong>内建组件原理</strong> 即可。</p><h2 id="第五篇-编译器" tabindex="-1">第五篇：编译器 <a class="header-anchor" href="#第五篇-编译器" aria-label="Permalink to &quot;第五篇：编译器&quot;">​</a></h2><p>编译器是一个非常复杂的环节。作者主要通过 <strong>编辑器核心逻辑、解析器、编译优化</strong> 这三个方向进行了说明。</p><p>其中对于我们日常开发与面试来说，最核心的就是 <strong>第十五章：编译器核心技术概述</strong> 。这也是咱们在这一篇中的主要章节。</p><h3 id="第十五章-编译器核心技术概述" tabindex="-1">第十五章：编译器核心技术概述 <a class="header-anchor" href="#第十五章-编译器核心技术概述" aria-label="Permalink to &quot;第十五章：编译器核心技术概述&quot;">​</a></h3><p>在编译器核心技术概述，主要包含两个核心内容：</p><ol><li>模板 <code>DSL</code> 的编译器</li><li><code>Vue</code> 编译流程三大步</li></ol><h4 id="模板-dsl-的编译器" tabindex="-1">模板 <code>DSL</code> 的编译器 <a class="header-anchor" href="#模板-dsl-的编译器" aria-label="Permalink to &quot;模板 `DSL` 的编译器&quot;">​</a></h4><p>在任何一个编程语言中，都存在编译器的概念。 <code>vue</code> 的编译器是在 <strong>一种领域下，特定语言的编译器</strong> ，那么这种编译器被叫做 <code>DSL</code> 编译器。</p><p>而编译器的本质是 <strong>通过一段程序，可以把 A 语言翻译成 B 语言</strong>。在 <code>vue</code> 中的体现就是 <strong>把 <code>tempalte</code> 模板，编译成 <code>render</code> 渲染函数</strong></p><p>一个完整的编译器，一个分为 <strong>两个阶段、六个流程</strong>：</p><ul><li>编译前端： <ul><li>词法分析</li><li>语法分析</li><li>语义分析</li></ul></li><li>编译后端： <ul><li>中间代码生成</li><li>优化</li><li>目标代码生成</li></ul></li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffad2f8700484c16a54ba64df0c0a0b8~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230209113241592.png"></p><p>而对于 <code>vue</code> 的编译器而言，因为它是一个特定领域下的编译器，所以流程会进行一些优化，一共分为三大步</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/217f4f7f06174c498ce14d61fd3b6c12~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230209113421705.png"></p><ol><li><code>parse</code>：通过 <code>parse</code> 函数，把模板编译成 <code>AST</code> 对象</li><li><code>transform</code>：通过 <code>transform</code> 函数，把 <code>AST</code> 转化为 <code>JavaScript AST</code></li><li><code>generate</code>：通过 <code>generate</code> 函数，把 <code>JavaScript AST</code> 转化为 渲染函数（<code>render</code>）</li></ol><p>这三大步中，每一步都包含非常复杂的逻辑实现。</p><p>和之前一样，因为篇幅的问题，我们没有办法这里去详细讲解三大步的流程。</p><p>我依然为大家提供了 <a href="https://juejin.cn/post/7197977396603256890/42118200" target="_blank" rel="noreferrer">免费的博客版</a> 和 <a href="https://coding.imooc.com/class/608.html" target="_blank" rel="noreferrer">收费的视频版</a> 。如果想要了解详细流程，那么可以自己进行选择。</p><h4 id="第十六章-解析器-parse" tabindex="-1">第十六章：解析器（parse） <a class="header-anchor" href="#第十六章-解析器-parse" aria-label="Permalink to &quot;第十六章：解析器（parse）&quot;">​</a></h4><p>这一章，主要详细讲解了 <strong>parse 解析逻辑</strong>。是在三大步中的 <code>parse</code> 逻辑的基础上，进行了一个加强。</p><p>所以这里咱们也按下不表</p><h4 id="第十七章-编译优化" tabindex="-1">第十七章：编译优化 <a class="header-anchor" href="#第十七章-编译优化" aria-label="Permalink to &quot;第十七章：编译优化&quot;">​</a></h4><p>最后就是编译优化。</p><p>编译优化也是一个非常大的概念，其核心就是 <strong>通过编译的手段提取关键信息，并以此知道生成最优代码的过程</strong>。</p><p>它的核心优化逻辑，主要是 <strong>把节点分为两类</strong>：</p><ul><li>第一类是 <strong>动态节点</strong>：也就是会 <strong>受数据变化影响</strong> 的节点</li><li>第二类是 <strong>静态节点</strong>：也就是 <strong>不受数据变化影响</strong> 的节点</li></ul><p>优化主要的点，就是 <strong>动态节点</strong>。</p><p>优化的方式主要是通过 <code>Block 树</code> 进行优化。</p><p><code>Block 树</code> 本质上就是一个 <strong>虚拟节点数对象</strong>，内部包含一个 <code>dynamicChildren</code> 属性，用来 <strong>收集所有的动态子节点</strong>，以达到提取关键点进行优化的目的。</p><p>除此之外，还有一些小的优化手段，比如：</p><ul><li>静态提升</li><li>预字符串化</li><li>缓存内联事件处理函数</li><li><code>v-once</code> 指令</li><li>...</li></ul><h3 id="第五篇总结" tabindex="-1">第五篇总结 <a class="header-anchor" href="#第五篇总结" aria-label="Permalink to &quot;第五篇总结&quot;">​</a></h3><p>其实第五篇编译器应该是整本书中，逻辑最复杂的一篇了。内部包含了特别多的代码实现。</p><p>但是因为篇幅问题，所以我们没有办法给大家进行详细介绍。只能是把大致的核心流程为大家进行明确。希望大家见谅。</p><h2 id="第六篇-服务端渲染" tabindex="-1">第六篇：服务端渲染 <a class="header-anchor" href="#第六篇-服务端渲染" aria-label="Permalink to &quot;第六篇：服务端渲染&quot;">​</a></h2><p>最后一篇只有一个章节，就是 <strong>同构渲染</strong>。</p><p>想要了解同构渲染，那么需要先搞明白 <code>CSR、SSR</code> 的概念。</p><ul><li><code>CSR</code>：所谓 <code>CSR</code> 指的是 <strong>客户端渲染</strong>。 <ul><li>浏览器向服务器发起请求</li><li>服务器查询数据库，返回数据</li><li>浏览器得到数据，进行页面构建</li></ul></li><li><code>SSR</code>：表示 <strong>服务端渲染</strong><ul><li>览器向服务器发起请求</li><li>服务器查询数据库，根据数据，生成 <code>HTML</code> ，并进行返回</li><li>浏览器直接渲染 <code>HTML</code></li></ul></li></ul><p>两种方式各有利弊，所以同构渲染，指的就是 <strong>把 <code>CSR</code> 和 <code>SSR</code> 进行合并</strong>。既可以单独 <code>CSR</code> ，也可以单独 <code>SSR</code>，同时还可以 <strong>结合两者，在首次渲染时，通过 <code>SSR</code>，在非首次渲染时，通过 <code>CSR</code></strong>。</p><p>以下是三者的对比图</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89708017acf04610b78efdd7ff4fa98c~tplv-k3u1fbpfcp-watermark.image?" alt="image-20230209121227934.png"></p><p>而针对 <code>vue</code> 的服务端渲染来说，它是 <strong>将虚拟 <code>DOM</code> 渲染为 <code>HTML</code> 字符串</strong>，本质上是 <strong>解析的 <code>vnode</code> 对象，然后进行的 <code>html</code> 的字符串拼接</strong></p><p>最后又讲解了客户端激活的原理，大致分为两步：</p><ol><li>为页面中的 <code>DOM</code> 元素与虚拟节点对象之间建立联系</li><li>为页面中的 <code>DOM</code> 元素添加事件绑定</li></ol><p>这两步主要是通过 <code>renderer.hydrate()</code> 方法进行实现了。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>那么到这里，整个 《Vue.js 设计与实现》就已经全部说完了。</p><p>整本书中，涉及到的内容是非常全面的，就像咱们开头所说的一样，它是一个 <strong>从高层的设计角度，来探讨框架需要关注的问题。</strong></p><p>我是 <code>Sunday</code>， 关注我，不迷路。和大家一起 <strong>读书</strong>，一起 <strong>分享技术知识</strong>。</p><hr><p><a href="https://juejin.cn/post/7195748379816493117" target="_blank" rel="noreferrer">如何高薪入职心仪的公司</a></p><p><a href="https://juejin.cn/post/7195491899746156603" target="_blank" rel="noreferrer">速读《软技能 代码之外的生存指南》</a></p><p><a href="https://juejin.cn/post/7193625406636261413" target="_blank" rel="noreferrer">8000 字读完《JavaScript 语言精粹(修订版)》</a></p><p><a href="https://juejin.cn/post/7190726242042118200" target="_blank" rel="noreferrer">Vue 3.2 源码系列</a></p><p>​</p>',312),a=[r];function p(n,s,l,i,g,u){return o(),c("div",null,a)}const b=e(t,[["render",p]]);export{f as __pageData,b as default};
