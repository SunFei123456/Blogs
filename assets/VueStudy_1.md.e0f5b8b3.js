import{_ as a,o as e,c as s,O as n}from"./chunks/framework.cb5c97e4.js";const C=JSON.parse('{"title":"vue2和vue3的区别","description":"","frontmatter":{},"headers":[],"relativePath":"VueStudy/1.md","filePath":"VueStudy/1.md"}'),l={name:"VueStudy/1.md"},o=n(`<h1 id="vue2和vue3的区别" tabindex="-1">vue2和vue3的区别 <a class="header-anchor" href="#vue2和vue3的区别" aria-label="Permalink to &quot;vue2和vue3的区别&quot;">​</a></h1><h2 id="_1-监测机制的改变" tabindex="-1">1. 监测机制的改变 <a class="header-anchor" href="#_1-监测机制的改变" aria-label="Permalink to &quot;1.  监测机制的改变&quot;">​</a></h2><ul><li>vue3 中使用了ES6 的 <code>Proxy</code>API 对数据代理，监测的是整个对象，而不再是某个属性。</li><li>消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制</li><li>vue3可以监测到对象属性的添加和删除，可以监听数组的变化；</li><li>vue3支持 Map、Set、WeakMap 和 WeakSet。</li></ul><h2 id="_2-vue3支持碎片-fragments" tabindex="-1">2. Vue3支持碎片(Fragments) <a class="header-anchor" href="#_2-vue3支持碎片-fragments" aria-label="Permalink to &quot;2. Vue3支持碎片(Fragments)&quot;">​</a></h2><pre><code>   Vue2在组件中只有一个根节点。
   Vue3在组件可以拥有多个根节点。
</code></pre><h2 id="_3-api模式不同" tabindex="-1">3. API模式不同 <a class="header-anchor" href="#_3-api模式不同" aria-label="Permalink to &quot;3.  API模式不同&quot;">​</a></h2><pre><code> Vue2与Vue3 \`最大的\`区别：Vue2使用\`选项式\`API（Options API）对比Vue3\`组合式\`API（Composition API）
</code></pre><h2 id="_4-建立数据的方式不同" tabindex="-1">4. 建立数据的方式不同 <a class="header-anchor" href="#_4-建立数据的方式不同" aria-label="Permalink to &quot;4.  建立数据的方式不同&quot;">​</a></h2><pre><code>Vue2：这里把数据放入data属性中
Vue3：需要使用一个新的setup()方法，
      此方法在组件初始化构造的时候触发。
</code></pre><p>使用以下三步来建立响应式数据:</p><pre><code>1.从vue引入 ref 或 reactive
2.简单数据类型使用 ref() 方法处理，
复杂类型数据用 reactive() 处理

3.使用 setup() 方法来返回我们的响应性数据，
从而我们的\`template\`可以\`获取\`这些响应性数据
</code></pre><h2 id="_5-生命周期钩子不同-—-lifecyle-hooks" tabindex="-1">5. 生命周期钩子不同 — <code>Lifecyle Hooks</code> <a class="header-anchor" href="#_5-生命周期钩子不同-—-lifecyle-hooks" aria-label="Permalink to &quot;5.  生命周期钩子不同 — \`Lifecyle Hooks\`&quot;">​</a></h2><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">setup</span><span style="color:#A6ACCD;">() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method</span></span>
<span class="line"><span style="color:#A6ACCD;">       </span><span style="color:#82AAFF;">onBeforeMount</span><span style="color:#A6ACCD;">() : 组件挂载到节点上之前执行的函数。</span></span>
<span class="line"><span style="color:#A6ACCD;">       </span><span style="color:#82AAFF;">onMounted</span><span style="color:#A6ACCD;">() : 组件挂载完成后执行的函数。</span></span>
<span class="line"><span style="color:#A6ACCD;">       </span><span style="color:#82AAFF;">onBeforeUpdate</span><span style="color:#A6ACCD;">(): 组件更新之前执行的函数。</span></span>
<span class="line"><span style="color:#A6ACCD;">       </span><span style="color:#82AAFF;">onUpdated</span><span style="color:#A6ACCD;">(): 组件更新完成之后执行的函数。</span></span>
<span class="line"><span style="color:#A6ACCD;">       </span><span style="color:#82AAFF;">onBeforeUnmount</span><span style="color:#A6ACCD;">(): 组件卸载之前执行的函数。</span></span>
<span class="line"><span style="color:#A6ACCD;">       </span><span style="color:#82AAFF;">onUnmounted</span><span style="color:#A6ACCD;">(): 组件卸载完成后执行的函数</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">若组件被</span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">&lt;keep-alive&gt;</span><span style="color:#89DDFF;">\`</span><span style="color:#A6ACCD;">包含，则多出下面两个钩子函</span></span>
<span class="line"><span style="color:#A6ACCD;">       </span><span style="color:#82AAFF;">onActivated</span><span style="color:#A6ACCD;">(): 被包含在中的组件，会多出两个生命周期钩子函数。被激活时执行</span></span>
<span class="line"><span style="color:#A6ACCD;">       </span><span style="color:#82AAFF;">onDeactivated</span><span style="color:#A6ACCD;">(): 比如从 A组件，切换到 B 组件，A 组件消失时执行</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_6-父子传参不同" tabindex="-1">6. <code>父子传参不同</code> <a class="header-anchor" href="#_6-父子传参不同" aria-label="Permalink to &quot;6.  \`父子传参不同\`&quot;">​</a></h2><p>子组件通过<code>defineProps()</code>进行接收，并且接收这个函数的返回值进行数据操作。</p><h2 id="_7-总结" tabindex="-1">7. 总结 <a class="header-anchor" href="#_7-总结" aria-label="Permalink to &quot;7. 总结&quot;">​</a></h2><p><strong>vue3 性能更高, 体积更小, 更利于复用, 代码维护更方便</strong></p>`,17),p=[o];function r(t,c,i,u,d,A){return e(),s("div",null,p)}const b=a(l,[["render",r]]);export{C as __pageData,b as default};
