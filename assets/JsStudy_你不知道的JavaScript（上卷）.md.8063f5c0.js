import{_ as e,o as c,c as t,O as a}from"./chunks/framework.cb5c97e4.js";const s="/Blogs/assets/image-20230312162056644.c5748169.png",d="/Blogs/assets/image-20230312162351296.dc6d631d.png",r="/Blogs/assets/image-20230312162810799.7adb81e6.png",i="/Blogs/assets/image-20230312195211200.fe557da4.png",l="/Blogs/assets/image-20230312195325623-8622006.a10bd1ee.png",p="/Blogs/assets/F3D8D8E2-F0B9-4B2B-ABC5-963789F4C08F.02508b31.jpeg",n="/Blogs/assets/image-20230312195731249.4fe12771.png",o="/Blogs/assets/image-20230313093931755.7391f15e.png",g="/Blogs/assets/image-20230313095212901.4589b5f8.png",h="/Blogs/assets/image-20230313103141530.70aeb946.png",m="/Blogs/assets/image-20230313103342338.09731fe8.png",b="/Blogs/assets/image-20230313103411871.daa8a1fc.png",_="/Blogs/assets/image-20230313104428805.35624ad4.png",f="/Blogs/assets/image-20230313105604789.d76a73a6.png",u="/Blogs/assets/image-20230312195211200.fe557da4.png",S="/Blogs/assets/image-20230313113036308.5ccd2ac8.png",v="/Blogs/assets/image-20230313113042179.b1f4d719.png",q="/Blogs/assets/image-20230313114708410.efe0ecba.png",k="/Blogs/assets/image-20230313114722831.4833558c.png",y="/Blogs/assets/image-20230313115016100.ce01a90c.png",J="/Blogs/assets/image-20230313115033555.505fe9fe.png",z="/Blogs/assets/image-20230313143336452.06e9cd4f.png",B="/Blogs/assets/image-20230313143343811.34e1e350.png",x="/Blogs/assets/image-20230313143457807.d340aece.png",w="/Blogs/assets/image-20230313143525400.6d3c3af9.png",P="/Blogs/assets/image-20230313153225432.1e9af24e.png",j="/Blogs/assets/image-20230313153419016.7f543c9e.png",H="/Blogs/assets/image-20230313153536270.1c0b0b0f.png",O="/Blogs/assets/image-20230313153856425.1e8705d9.png",R="/Blogs/assets/image-20230313155434922.2551a04f.png",L="/Blogs/assets/image-20230313155447173.c878bd87.png",E="/Blogs/assets/image-20230313174231848.a9b90dc8.png",D="/Blogs/assets/image-20230313174903812.a7e587db.png",I=JSON.parse('{"title":"你不知道的JavaScript(上卷)","description":"","frontmatter":{},"headers":[],"relativePath":"JsStudy/你不知道的JavaScript（上卷）.md","filePath":"JsStudy/你不知道的JavaScript（上卷）.md"}'),C={name:"JsStudy/你不知道的JavaScript（上卷）.md"},N=a('<h1 id="你不知道的javascript-上卷" tabindex="-1">你不知道的JavaScript(上卷) <a class="header-anchor" href="#你不知道的javascript-上卷" aria-label="Permalink to &quot;你不知道的JavaScript(上卷)&quot;">​</a></h1><p>这是一本由 <code>180 名程序员</code> 共同完成的，并且在 <a href="https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN" target="_blank" rel="noreferrer">github</a> 上开源的书籍。也是一度被前端开发者奉为 “神作” 的 <code>JavaScript</code> 进阶必读书籍。</p><h1 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h1><p><code>hello</code>，大家好，我是 <code>Sunday</code>。</p><p>《你不知道的JavaScript》，一共被分为了上、中、下 三卷。其中上卷应该是其中的佼佼者，在豆瓣评分高达 <code>9.4</code> 分</p><img src="'+s+'" alt="image-20230312162056644" style="zoom:50%;"><p>同时这本书也在 <code>github</code> 上进行了开源，共有 <code>180</code> 位贡献者</p><img src="'+d+'" alt="image-20230312162351296" style="zoom:50%;"><p>可以说，这本书是集合了众多优秀的开发者的智慧来共同完成的。</p><p>本书是在 <code>2015 年 4 月</code> 出版，我手中的这本是 <code>2016年 3 月</code> 的第四次印刷版</p><p><img src="'+r+'" alt="image-20230312162810799"></p><p>那么在当下（<code>2023 年</code>）这个时间点，我们再次打开这本当年的 “神作”，它还能够给我们带来什么启示呢？让我们拭目以待吧！</p><h1 id="正文" tabindex="-1">正文 <a class="header-anchor" href="#正文" aria-label="Permalink to &quot;正文&quot;">​</a></h1><h2 id="大纲" tabindex="-1">大纲 <a class="header-anchor" href="#大纲" aria-label="Permalink to &quot;大纲&quot;">​</a></h2><p>整本书一共分为 <strong>两个部分</strong>，共计 <strong>十一个章节</strong>。</p><h3 id="第一部分-作用域与闭包" tabindex="-1">第一部分：作用域与闭包 <a class="header-anchor" href="#第一部分-作用域与闭包" aria-label="Permalink to &quot;第一部分：作用域与闭包&quot;">​</a></h3><p>首先是第一部分 <strong>作用域与闭包</strong>。在这一部分中，作者从底层入手，来为我们介绍了什么是作用域。通过对 <code>JS</code>编译原理的分析，引出 <strong>词法作用域</strong> 的概念，进而牵扯出 函数作用域与块作用域。</p><p>然后又通过编辑器的解析流程，引出了 <code>JS</code> 中变量提升的概念，从而解释了最终的 <strong>作用域与闭包</strong>。</p><h3 id="第二部分-this-和对象原型" tabindex="-1">第二部分：this 和对象原型 <a class="header-anchor" href="#第二部分-this-和对象原型" aria-label="Permalink to &quot;第二部分：this 和对象原型&quot;">​</a></h3><p>接下来是第二部分 <strong>this 和对象原型</strong>。<code>this</code> 的指向问题一直是前端领域的一个痛点问题，作者在这里对 <code>this</code> 的指向进行了全面的解析，从 <code>4</code> 个方向分析了 <code>this</code> 的绑定规则，并且给出了绑定规则之间的优先级关系。同时作者还对 <strong>对象、类</strong> 进行了一些进阶的分析，比如 <strong>对象的属性描述符、冻结对象属性的方式、<code>getter</code> 行为和 <code>setter</code> 行为</strong>。同时也提出了一些别具一格的理论，比如 <strong>类在 JS 中是一种可选的设计模式</strong></p><p>综上所述，其实我们就可以知道，在上卷中，其实作者主要就介绍了 <code>5个</code> 知识点：<strong>作用域、闭包、this 、 对象 和 类</strong></p><h2 id="第一部分-1-作用域是什么" tabindex="-1">第一部分：① 作用域是什么 <a class="header-anchor" href="#第一部分-1-作用域是什么" aria-label="Permalink to &quot;第一部分：① 作用域是什么&quot;">​</a></h2><p>说起作用域相信很多同学肯定都已经不陌生了。但是从 <strong>JS 编译原理</strong> 开始讲作用域的，大家应该都是头一次见吧。</p><blockquote><p>作者告诉我们，想要了解作用域啊，你首先得先 “搞明白 JS 编译原理”。</p></blockquote><p>那么下面咱们就来看看 <strong>JS 编译原理</strong> 是什么。</p><h3 id="js-的编译原理" tabindex="-1">JS 的编译原理 <a class="header-anchor" href="#js-的编译原理" aria-label="Permalink to &quot;JS 的编译原理&quot;">​</a></h3><blockquote><p>所谓编译指的是：源代码执行之前进行的操作。</p></blockquote><p>而对于 <code>JS</code> 而言，它的整个编译过程被粗略分为三大步：</p><ol><li>分词 - 词法分析</li><li>解析 - 语法分析</li><li>代码生成</li></ol><p>首先对于 <strong>词法分析</strong> 而言，它的主要作用就是： <strong>把一段 <code>JS</code> 代码，解析成多个词法单元（<code>token</code>）</strong>。我们以 <code>var a = 2;</code> 为例，他会被解析成 <code>5</code> 个 <code>token</code>：<code>var、a、=、2、;</code></p><p>其次是 <strong>语法分析</strong>，它的作用是： **把 <code>token</code> 流转化为 <code>AST （抽象语法树）</code> **。所谓抽象语法树就是一个 <strong>树形结构的 <code>JS</code> 对象</strong></p><p>最后是 <strong>代码生成</strong>，它的作用是：<strong>把 <code>AST</code> 解析成可执行的代码（机器指令）</strong></p><h3 id="理解作用域" tabindex="-1">理解作用域 <a class="header-anchor" href="#理解作用域" aria-label="Permalink to &quot;理解作用域&quot;">​</a></h3><p>明确好了这三步基础的 <code>JS 编译原理</code> 之后，那么下面我们来尝试理解一下作用域。</p><p>作者告诉我们：“作用域的理解需要从一个故事开始~~”。</p><p>既然是故事嘛，那肯定得有演员。咱们这次出动了三个演员：</p><ol><li>引擎：负责整个 JavaScript 程序的编译及执行过程（核心）</li><li>编译器：负责语法分析及代码生成等（编译三步）</li><li>作用域：负责收集并维护由所有变量查询，并确定访问权限</li></ol><p>明确好这些演员之后，接下来咱们来看这个故事：</p><blockquote><p><strong>引擎</strong> 有一天看见了一段代码 <code>var a = 2; </code>，这段代码在引擎看来是两段完全不同的内容，所以引擎把这段代码拆成了两部分：</p><ol><li><code>var a</code></li><li><code>a = 2</code></li></ol><p>然后把第一段代码交给了 <strong>编译器</strong>，编译器就拿着这段代码问 <strong>作用域</strong>，你那有 <code>a</code> 这个变量吗？作用域如果说有，那么编译器就会忽略掉这段声明。否则，则进行 <code>a</code> 变量声明。</p><p>接下来，<strong>编译器</strong> 会为 <strong>引擎</strong> 生成运行时所需的代码，这些代码被用来处理 <code>a = 2</code> 这个赋值操作。</p><p><strong>引擎</strong> 会首先询问 <strong>作用域</strong>：在当前的作用域集合中是否存在一个叫作 <code>a</code> 的 变量。如果是，<strong>引擎</strong> 就会使用这个变量。否则，<strong>引擎</strong> 会继续查找该变量（这就涉及到另外一个概念 <strong>作用域嵌套</strong>）。</p></blockquote><p>在这样的一个故事中，会涉及到两个关键术语：<code>LHS</code> 和 <code>RHS</code>。</p><ul><li><code>LHS</code>：赋值操作的左侧查询。这并不意味着 <code>LHS</code> 就是赋值符号左侧的操作。大家可以用这句话进行理解 <strong>找到变量，对其赋值</strong></li><li><code>RHS</code>：赋值操作的右侧查询。同样的道理，它也并不是赋值符号的右侧操作。大家可以用这句话进行理解 <strong>取得某变量的值</strong></li></ul><p>如果只是这么说，可能大多数同学依然听不懂，咱们下面通过一个例子来看一下。</p><blockquote><p>现在有这样一段代码：</p><img src="'+i+'" alt="image-20230312195211200" style="zoom:33%;"><p>在这段代码中涉及到了 <strong>一次 <code>LHS</code> 查询，三次 <code>RHS</code> 查询</strong>。然后我们通过对话的形式来看一下：</p><p><img src="'+l+'" alt="image-20230312195325623"></p><p>查询步骤为：</p><ol><li>RHS：foo(2)</li><li>LHS：a = 2</li><li>RHS：console</li><li>RHS：xxx.log(a)</li></ol></blockquote><p><code>OK</code>，如果大家能够理解 <code>LHS、RHS</code> 的话，那么作者还 “很贴心的” 给我们准备了一个测试例子</p><p><img src="'+p+'" alt="我TM谢谢你什么梗_抖音我TM谢谢你意思、含义、出处介绍_游戏吧"></p><p>在这个例子中，一共存在 <strong>3 次 <code>LHS</code>、4 次 <code>RHS</code></strong> ，大家看看能不能找到的呢：</p><img src="'+n+'" alt="image-20230312195731249" style="zoom:50%;"><p>操作流程如下：</p><ul><li>LHS：var c = xx</li><li>RHS：foo(2)</li><li>LHS：a = 2</li><li>LHS：var b = xx</li><li>RHS: xxx = a</li><li>RHS：a</li><li>RHS：b</li></ul><h3 id="作用域嵌套" tabindex="-1">作用域嵌套 <a class="header-anchor" href="#作用域嵌套" aria-label="Permalink to &quot;作用域嵌套&quot;">​</a></h3><p>作用域嵌套的概念，相信大多数同学应该都比较熟悉。咱们来看这段代码：</p><img src="'+o+'" alt="image-20230313093931755" style="zoom:33%;"><p>在这段代码中，我们在 <code>foo</code> 函数中写入了一个 <code>bar</code> 函数。那么此时在这段代码中就存在 <code>3</code> 个作用域：</p><ol><li>全局作用域</li><li><code>foo</code> 函数作用域</li><li><code>bar</code> 函数作用域</li></ol><p>这三个作用域组合在一起，就叫做 <strong>作用域嵌套</strong>。</p><p>当我们在 <code>bar</code> 函数中访问变量 <code>a</code> 的时候，<code>bar</code> 函数作用域中没有 <code>a</code> 变量，所以会向上层进行查找，直到在 <code>foo</code> 作用域中找到 <code>a</code> 变量。 那么这种 <strong>逐层向上层作用域查找</strong> 的机制，就是作用域嵌套时变量查找机制。</p><p>作用在书中给了我们一张图来表示这种 <strong>逐层向上</strong> 的查找机制：</p><img src="'+g+'" alt="image-20230313095212901" style="zoom:20%;"><h3 id="异常" tabindex="-1">异常 <a class="header-anchor" href="#异常" aria-label="Permalink to &quot;异常&quot;">​</a></h3><p>在 <strong>逐层向上</strong> 的查找过程中，引擎会从变量当前作用域开始，一直查找到全局作用域。如果到全局作用域还如法查找到变量的话，那么就会抛出 <code>ReferenceError 异常</code> 。</p><p><code>ReferenceError 异常</code> 表示 <strong>RHS 查询在所有嵌套的作用域中遍寻不到所需的变量</strong>。</p><p>而对于 <code>LHS 查询</code> 而言，如果在非严格模式下（例 <code>a = 2</code>），<strong>编译器会在全局作用于下声明该变量，然后再为其赋值</strong>。</p><p>而如果在严格模式下，同样会抛出 <code>ReferenceError 异常</code></p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>那么在第一章中，我们了解了 <strong>引擎、编译器、作用域</strong> 三者之间的关系，同时也知道了 <strong>LHS 和 RHS</strong> 的区别。 基于以上的内容，我们对 <code>作用域</code> 做一个定义：</p><blockquote><p>所谓作用域指的是一套规则：<strong>这套规则规定如何存储变量，并且之后可以方便的找到这些变量</strong>。</p></blockquote><h2 id="第一部分-2-词法作用域" tabindex="-1">第一部分：② 词法作用域 <a class="header-anchor" href="#第一部分-2-词法作用域" aria-label="Permalink to &quot;第一部分：② 词法作用域&quot;">​</a></h2><p>那么了解了作用域的基本概念之后，接下来咱们来看 <strong>作用域下词法作用域</strong> 的概念。</p><p>所谓词法作用域指的是：<strong>定义表达式并能被访问的区间</strong></p><p>我们还是来看刚才的那段代码：</p><img src="'+o+'" alt="image-20230313093931755" style="zoom:33%;"><p>在这段代码中，我们知道它包含了三级作用域：</p><ul><li><p>① 包含着整个全局作用域，其中只有一个标识符：<code>foo</code></p></li><li><p>② 包含着 <code>foo</code> 所创建的作用域，其中有三个标识符：<code>a</code>、<code>bar</code> 和 <code>b</code></p></li><li><p>③ 包含着 <code>bar</code> 所创建的作用域，其中只有一个标识符：<code>c</code></p></li></ul><p>这三个作用域其实就是词法作用域的概念。</p><p>同时 <code>JS</code> 中为我们提供了两个 <code>API</code> 来 “欺骗” 作用域，也就是 <strong>欺骗词法</strong>。</p><p>第一个欺骗词法是 <code>eval</code>：<code>eval()</code> 函数会将传入的字符串当做 <code>JavaScript</code> 代码进行执行。利用该语法我们可以把 <strong>指定代码，指定在局部作用域下执行</strong>：</p><img src="'+h+'" alt="image-20230313103141530" style="zoom:33%;"><p>第二个欺骗词法是 <code>with</code>：它的作用是 <strong>扩展一个语句的作用域链</strong>。比如在如下代码中 <code>with</code> 内的代码，会自动指向 <code>obj</code> 对象：</p><img src="'+m+'" alt="image-20230313103342338" style="zoom:33%;"><p>但是要注意，<code>with</code> 语法可能会导致内存泄漏：</p><img src="'+b+'" alt="image-20230313103411871" style="zoom:33%;"><p>并且 <code>with</code> 会让作用域变得混乱，所以 <strong>它是一个不被推荐使用的语法</strong>。</p><p>不光是 <code>with</code>，包括 <code>eval</code> ，它们两个都不应该是我们在日常开发时的首选项，因为它们改变作用域的特性，会导致 <strong>引擎无法在编译时对作用域查找进行优化</strong> ，所以我们应该尽量避免使用 <code>eval</code> 和 <code>with</code>。</p><h2 id="第一部分-3-函数作用域与块作用域" tabindex="-1">第一部分：③ 函数作用域与块作用域 <a class="header-anchor" href="#第一部分-3-函数作用域与块作用域" aria-label="Permalink to &quot;第一部分：③ 函数作用域与块作用域&quot;">​</a></h2><p>了解了词法作用域之后，接下来咱们来看下函数作用于和块级作用域。</p><p>首先针对函数作用于而言，它表示 <strong>一个函数的作用域范围。属于这个函数的全部变量都可以在整个函数的范围内使用及复用</strong></p><p>我们之前很多次的说过 <strong>函数是 js 世界的第一公民</strong>。创建函数的目的，本质上其实就是为了 <strong>把代码 “隐藏” 起来</strong>。也就是 <strong>最小特权原则</strong>。</p><p>所谓 <strong>最小特权原则</strong>，指的是：<strong>最小限度地暴露必要内容，而将其他内容都“隐藏”起来</strong>。</p><p>但是在某些情况下，如果我们的代码不够完善的话，那么虽然创建了函数，但是依然不符合最小特权原则。比如下面这段代码：</p><img src="'+_+'" alt="image-20230313104428805" style="zoom:50%;"><p>在这段代码中，我们声明了一个全局变量 <code>var b</code>。然后在函数中对 <code>b</code> 进行了操作。但是因为 <code>b</code> 是全局变量，所以我们可以在任意位置修改 <code>b</code> 的值，那么这样的一个操作就是 “非常危险” 的。此时的代码就不符合最小特权原则。</p><p>我们可以对当前代码进行下修改，把 <code>b</code> 的定义放到函数之后，以避免被全局访问 ：</p><img src="'+f+'" alt="image-20230313105604789" style="zoom:50%;"><p>同时大家需要注意，因为 <code>var</code> 关键字 <strong>不包含块级作用域</strong>，所以大家使用的时候要避免出现冲突的问题。</p><img src="'+u+'" alt="image-20230313105759893" style="zoom:50%;"><p><code>ECMAScript</code> 在 <code>ES6</code> 之后新增了 <code>let</code> 和 <code>const</code> 两个声明变量的关键字，这两个关键字具备块级作用域（<code>{}</code> 组成块级作用域），同时 <code>var</code> 也不再被推荐使用了。所以冲突问题倒是可以比较轻松的避免。</p><h2 id="第一部分-4-提升" tabindex="-1">第一部分：④ 提升 <a class="header-anchor" href="#第一部分-4-提升" aria-label="Permalink to &quot;第一部分：④ 提升&quot;">​</a></h2><p>所谓提升指的是 <strong>变量提升</strong> 的问题，什么是变量提升呢？咱们来看这两段代码：</p><p><img src="'+S+'" alt="image-20230313113036308" style="zoom:50%;"><img src="'+v+'" alt="image-20230313113042179" style="zoom:50%;"></p><p>大家可以猜一下这两段代码输出的内容是什么？</p><p>第一段代码的输出结果是 <code>2</code>。</p><p>第二段代码的输出结果是 <code>undefined</code>。</p><p>如果我们从一个标准的程序设计角度，这样的代码是肯定不能正常运行的。但是因为 <code>var</code> 存在变量提升的问题，所以我们得到了以上两个对应的输出结果。</p><p>那么这个变量提升到底是怎么提升的呢？此时啊，编译器就有话说了。</p><p>整个 <code>var a = 2;</code> 的代码编译器在处理会分成两部分：</p><ol><li>在 编译阶段，进行定义声明：<code>var a</code></li><li>在 执行阶段，进行赋值声明：<code>a = 2</code></li></ol><p>根据声明提升，第一段代码会被解析为以下代码：</p><img src="'+q+'" alt="image-20230313114708410" style="zoom:50%;"><p>第二段代码会被解析为以下代码：</p><img src="'+k+'" alt="image-20230313114722831" style="zoom:50%;"><p>查看变量提升之后的代码，我们就可以很清楚的知道为什么会打印出刚才看到的结果了。</p><p>而对于函数而言，同样存在变量提升的问题，同时 <strong>当函数和变量同时需要提升时</strong>，遵循 <strong>函数优先原则</strong>。例如，以下代码：</p><img src="'+y+'" alt="image-20230313115016100" style="zoom:50%;"><p>被提升之后的内容为：</p><img src="'+J+'" alt="image-20230313115033555" style="zoom:50%;"><h3 id="总结-1" tabindex="-1">总结 <a class="header-anchor" href="#总结-1" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>对于变量提升而言，它其实是一个 <code>JS</code> 中的糟粕，新的 <code>let</code> 和 <code>const</code> 关键字已经不存在变量提升的问题。但是变量提升在面试中依然会经常被问到，所以我们还是需要有所了解的。</p><p>当然，也仅仅只是了解一下就可以了。</p><h2 id="第一部分-5-作用域与闭包" tabindex="-1">第一部分：⑤ 作用域与闭包 <a class="header-anchor" href="#第一部分-5-作用域与闭包" aria-label="Permalink to &quot;第一部分：⑤ 作用域与闭包&quot;">​</a></h2><p>到这里，对作用域咱们了解的其实就差不多了。作者分别从 <strong>词法作用域、函数作用域、块作用域</strong> 三个方面对作用域进行了解释。</p><p>在第一部分的最后，作者提到了闭包的概念。闭包在我们现在看来已经是一个老生常谈的话题了，如果大家了解闭包的话，那么可以知道，在前面我们所讲到的代码中，很多代码都存在闭包。</p><p>那么什么是闭包呢？所为闭包一定是一个函数。通常情况下我们把 <strong>能够访问其它函数作用域中变量的函数</strong> 叫做闭包函数。</p><p>闭包函数在前端开发中是非常常见的，比如：</p><img src="'+z+'" alt="image-20230313143336452" style="zoom:33%;"><img src="'+B+'" alt="image-20230313143343811" style="zoom:25%;"><p>这两个函数，都可以被叫做闭包函数。</p><p>在 <code>var</code> 时代，因为 <code>var</code> 不存在块级作用域，所以如果我们进行以下代码输出的话，那么会得到 <code>5 次 6</code> 的输出结果。</p><img src="'+x+'" alt="image-20230313143457807" style="zoom:33%;"><p>而想要解决这个问题，就可以利用闭包进行解决：</p><img src="'+w+'" alt="image-20230313143525400" style="zoom:33%;"><p>而对于现在而言，如果我们通过 <code>let</code> 代替 <code>var</code> 的话，那么就不会在出现这样的问题了。</p><h2 id="第一部分-总结" tabindex="-1">第一部分：总结 <a class="header-anchor" href="#第一部分-总结" aria-label="Permalink to &quot;第一部分：总结&quot;">​</a></h2><p>那么到这里，整个第一部分就说完了。整本书中第一部分所涉及到的东西其实还是很多的。所以我们把重点给大家列一下。</p><p>整个第一部分，重点一共有 <code>5</code> 点：</p><ul><li>① 编译流程：整个编译的三大步，包括 <code>词法单元 token</code>、<code>AST</code> 这些东西大家最好可以有一个印象。因为如果你想要成为高级开发者，那么这些东西是需要有一定的了解的。</li><li>② 引擎、编译器、作用域：三者的作用，以及他们之间配合协作的方式，也需要有一个大致的印象。</li><li>③ <code>LHS</code> &amp;&amp; <code>RHS</code>：这也是偏底层的内容了，有所了解就可以。</li><li>④ <code>eval</code> &amp;&amp; <code>with</code>：这两个欺骗语法，需要有一个了解，至少要知道他们的作用。我在一次录制 <a href="https://www.bilibili.com/video/BV1U24y1g7oW/" target="_blank" rel="noreferrer">面试视频</a> 的时候，就被问到了 <code>with</code> 的作用，如果回答不上来就很尴尬了。</li><li>⑤ <code>let</code> &amp;&amp; <code>const</code> 可以解决块级作用域与变量提升：这个在现时代看来应该算是一个常识操作了，如果不了解的话，可以看下咱们之前讲过的 <a href="https://www.bilibili.com/video/BV1qD4y1G7YK/?vd_source=391a8dc379e0da60c77490e3221f097a" target="_blank" rel="noreferrer">一小时读完《深入理解现代 JavaScript》，彻底掌握 ES6 之后 JavaScript 新特性！</a> ，这里咱们就不去多数说了哈。</li></ul><h2 id="第二部分-1-关于-this" tabindex="-1">第二部分：① 关于 this <a class="header-anchor" href="#第二部分-1-关于-this" aria-label="Permalink to &quot;第二部分：① 关于 this&quot;">​</a></h2><p>接下来，咱们来看第二部分 <strong>this 和对象原型</strong>。</p><p>说起 <code>this</code>，它也是一个老生常谈的话题了。作者在书中先描述了一堆错误的 <code>this</code> 指向问题，然后再描述了正确 <code>this</code> 指向问题。</p><p>对于错误的 <code>this</code> 描述，我就不给大家重复了。毕竟很多时候我们只需要知道正确的答案就可以了。</p><p>所谓 <code>this</code> ，大家首先需要知道 <strong>它是在运行时进行绑定的，它的上下文取决于函数调用时的各种条件。</strong> 也就是说， <code>this</code> 的值到底是什么，取决于它所在的函数被调用时的上下文，而和它所在的函数定义时没有关系。</p><p>同时大家要注意，以上这些描述 <strong>仅针对于 <code>function</code> 声明的普通函数</strong>，因为我们知道 <strong>箭头函数是不会修改 <code>this</code> 指向的。</strong></p><h2 id="第二部分-2-this-全面解析" tabindex="-1">第二部分：② this 全面解析 <a class="header-anchor" href="#第二部分-2-this-全面解析" aria-label="Permalink to &quot;第二部分：② this 全面解析&quot;">​</a></h2><p>那么明确好了 <code>this</code> 的概念之后，下面咱们就来看看 <code>this</code> 指向的相关问题。</p><p>刚才我们说过， <code>this</code> 的指向取决于调用函数时的上下文，所以想要确定 <code>this</code> 的指向，我们需要先能够判定函数的调用位置：</p><img src="'+P+'" alt="image-20230313153225432" style="zoom:25%;"><p>这段代码为我们描述了函数的调用位置。</p><p>明确好了什么叫做函数的调用位置之后，下面咱们来看 <code>this</code> 的绑定规则。</p><p>作者把 <code>this</code> 的绑定规则分为了 <code>4</code> 类，虽然类数有点多，但是并不复杂，咱们一起来看一下：</p><ol><li>默认绑定：这是在全局作用域下 <code>this</code> 的指向。全局作用域下 <code>this</code> 指向 <code>window</code><img src="'+j+'" alt="image-20230313153419016" style="zoom:33%;"></li><li>隐式绑定：以对象方法的形式进行的函数调用，此时 <code>this</code> 指向调用该函数的对象 <img src="'+H+'" alt="image-20230313153536270" style="zoom:33%;"></li><li>显式绑定：<code>call、apply、bind</code> 这三个方法。这三个方法的第一个参数，为函数内 <code>this</code> 的指向。</li><li><code>new</code> 绑定：主要针对构造函数。在这种情况下 <code>this</code> 指向构造生成的实例对象 <img src="'+O+'" alt="image-20230313153856425" style="zoom:33%;"></li></ol><p>明确好了 <code>this</code> 的绑定规则之后，接下来作者告诉了我们如何来去判定 <code>this</code> 的指向，也就是 <strong><code>this</code> 指向的判定规则</strong>，一共也是分为 <code>4</code> 步：</p><ol><li><code>var bar = new foo()</code>：函数是否在<code>new</code>中调用（new绑定）？如果是的话，<code>this</code> 绑定的是新创建的对象。</li><li><code>var bar = foo.call(obj2)</code>：函数是否通过<code>call、apply</code>（显式绑定）调用？如果是的话，<code>this</code> 绑定的是指定的对象。</li><li><code>var bar = obj1.foo()</code>：函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，<code>this</code> 绑定的是那个上 下文对象。</li><li><code>var bar = foo()</code>：如果以上都不是的话，则使用默认绑定。如果在严格模式下，就绑定到<code>undefined</code>，否则绑定到 全局对象（<code>window</code>）。</li></ol><p>通过以上这四步，我们基本上可以把 <code>this</code> 所涉及到的所有场景都描述下来了。</p><p>但是大家一定要注意，以上所有的内容，<strong>仅针对 <code>function</code> 函数</strong>。因为 <strong>箭头函数永不修改 <code>this</code> 指向</strong></p><h2 id="第二部分-3-对象" tabindex="-1">第二部分：③ 对象 <a class="header-anchor" href="#第二部分-3-对象" aria-label="Permalink to &quot;第二部分：③ 对象&quot;">​</a></h2><p><code>this</code> 说完之后，接下来我们来看对象。</p><p>在 <code>JS</code> 中，数据类型一共分为两大类：</p><ul><li>基本数据类型</li><li>复杂数据类型</li></ul><p>其中基本数据类型包括：<code>string、number、boolean、null、undefined</code>， <code>ES6</code> 之后又新增了两种，书中没有提到，这两种是 <code>symbol、bigint</code>。</p><p>而基本数据类型，指的其实就是对象，具体可以细分为 <code>Object</code>、<code>Function</code>、<code>Array</code> 三大类（有些同学会在复杂数据类型中加上 <code>data</code> 等其他的类型，这个主要看个人理解）。</p><p>而我们接下来要说的对象，指的仅为 <code>object</code>。</p><p>在 <code>JS</code> 中，想要创建一个对象的话，那么有两种方式：</p><ol><li>字面量形式：<img src="'+R+'" alt="image-20230313155434922" style="zoom:33%;"></li><li>构造形式：<img src="'+L+'" alt="image-20230313155447173" style="zoom:33%;"></li></ol><p>而对于对象的使用（内容），作者在本章中花费了很多的笔墨来进行讲解，整个讲解的内容大致分为了 <code>7</code> 点。</p><ol><li><p>对象的属性名永远是 <strong>字符串</strong>。这个不用多说，大家应该是知道的。</p></li><li><p>其次对象的访问有两种形式：<code>属性访问：obj.key</code> 和 <code>键访问：obj[key]</code> 。其中第一种是常用的方式，第二种主要针对 <code>key</code> 是变量时使用</p></li><li><p>第三：数组也是对象。这个应该也不需要多说才对。</p></li><li><p>第四拷贝：对象的拷贝分为 <strong>浅拷贝</strong> 和 <strong>深拷贝</strong> 两种。</p><ol><li>浅拷贝表示多个变量引用了同一块内存地址。操作方式也比较简单，可以直接通过 <code>= 赋值符</code> 或 <code>Object.assgin</code> 进行实现。</li><li>深拷贝又分为两种： <ol><li>浅层的深拷贝（对象下不再包含复杂数据类型）：对于这种可以直接通过 <code>JSON.parse( JSON.stringify( obj ) );</code> 的方式完成</li><li>深层的深拷贝（对象下还包含其他复杂数据类型数据）：对于这种必须要通过 <strong>递归</strong> 的方式完成深拷贝。比较简单的方式就是直接使用 <a href="https://www.geeksforgeeks.org/lodash-_-clonedeep-method/" target="_blank" rel="noreferrer">Lodash.cloneDeep 方法</a></li></ol></li></ol></li><li><p>第五属性描述符：对象中每个属性，都存在属性描述符。可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" rel="noreferrer">Object.getOwnPropertyDescriptor()</a> 方法来获取对应的属性描述符。不同的属性描述符代表了不同的作用：</p><ol><li><strong><code>value</code></strong>：该属性的值 (仅针对数据属性描述符有效)</li><li><strong><code>writable</code></strong>：当且仅当属性的值可以被改变时为 <code>true</code>。</li><li><strong><code>configurable</code></strong>：当且仅当指定对象的属性描述可以被改变或者属性可被删除时，为 <code>true</code>。</li><li><strong><code>enumerable</code></strong>：当且仅当指定对象的属性可以被枚举出时，为 <code>true</code>。</li></ol><p>也可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noreferrer">Object.defineProperty()</a> 方法修改指定属性的属性描述符。</p></li><li><p>第六是 对象属性不可变的方法：作者在这里一共列举出了四个方法，大家可以作为了解：</p><ol><li>对象常量：结合 <code>writable:false</code> 和 <code>configurable:false</code> 就可以创建一个真正的常量属性</li><li>禁止扩展：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions" target="_blank" rel="noreferrer">Object.preventExtensions(..)</a></li><li>密封：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal" target="_blank" rel="noreferrer">Object.seal</a></li><li>冻结：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank" rel="noreferrer">Object.freeze()</a></li></ol></li><li><p>第七是 <code>getter 与 setter</code>：这里主要是两个标记符，他可以让我们像调用属性一样触发方法 <img src="'+E+'" alt="image-20230313174231848" style="zoom:33%;"></p></li></ol><p>关于对象的最后一个环节就是枚举了。本书在讲解枚举的时候，并不贴近现在的 <code>JS</code> 使用场景，如果大家想要了解对象枚举的方式的话，可以看下我讲解的另一本书 <a href="https://www.bilibili.com/video/BV1qD4y1G7YK/?vd_source=391a8dc379e0da60c77490e3221f097a" target="_blank" rel="noreferrer">《深入理解现代 JavaScript》</a></p><h2 id="第二部分-4-混合对象-类" tabindex="-1">第二部分：④ 混合对象 “类” <a class="header-anchor" href="#第二部分-4-混合对象-类" aria-label="Permalink to &quot;第二部分：④ 混合对象 “类”&quot;">​</a></h2><p>了解完了对象之后，接下来我们来看 “类”。</p><p>想要了解类的话，那么大家需要首先搞明白 <strong>对象和类的区别</strong>。</p><blockquote><p>对象永远指的是一个具体的实例，而类指的是某一类事物。</p><p>比如：</p><p>以汽车为类，具体的某一辆汽车可以称之为对象（实例对象）。</p><p>以人为类，具体的某一个人可以称之为对象（实例对象）。</p></blockquote><p>类本质上是一种设计模式。所以在 <code>JS</code> 中类是可选的模式。大家可以想一想在大家的日常项目开发中，如果你是以 <code>vue</code> 为主的话，那么应该几乎没有使用过类的概念才对。 <code>react</code> 的同学可能对 <code>class</code> 的概念使用的会多一些。</p><p>基于类的设计模式，我们可以在 <code>JS</code> 中构建出类似的代码逻辑：</p><img src="'+D+'" alt="image-20230313174903812" style="zoom:33%;"><p>这个代码主要使用到了 <code>ES6</code> 的 <code>class</code> 关键字构建了类，然后通过 <code>new</code> 创建了对应的实例对象。</p><p>同时针对于类而言，它是存在继承的概念的。因为存在继承，所以延伸出了多态的概念。所谓多态指的是 <strong>从一个父类派生出多个子类，可以使子类之间有不同的行为，这种行为称之为多态</strong> 。</p><p>而具体在 <code>JS</code> 中如何进行继承，作者在书中描述的并不详尽，所以大家如果想要了解 <code>JS</code> 中类继承的语法 ，我更建议大家去看 <a href="https://www.bilibili.com/video/BV1qD4y1G7YK/?vd_source=391a8dc379e0da60c77490e3221f097a" target="_blank" rel="noreferrer">《深入理解现代 JavaScript》</a></p><h2 id="第二部分-5-原型" tabindex="-1">第二部分：⑤ 原型 <a class="header-anchor" href="#第二部分-5-原型" aria-label="Permalink to &quot;第二部分：⑤ 原型&quot;">​</a></h2><p>而对于 <code>JS</code> 来说，原型和原型链同样也是一个经久不衰的话题。</p><p>所谓的原型指的就是 <code>[[prototype]]</code>，每个 <code>JS</code> 对象都存在 <code>[[prototype]]</code> 属性，该属性就是该对象的原型对象。原型对象也是对象，所以它也存在 <code>[[prototype]]</code> 属性，也就是 <strong>原型对象的原型对象</strong>。同样原型对象的原型对象也存在 <code>[[prototype]]</code>。这就连成了一个链，这个链被叫做 <strong>原型链</strong>。整个原型链一直到 <code>null</code> 为止。</p><h2 id="第二部分-剩余内容" tabindex="-1">第二部分：剩余内容 <a class="header-anchor" href="#第二部分-剩余内容" aria-label="Permalink to &quot;第二部分：剩余内容&quot;">​</a></h2><p>到这里其实咱们整个第二部分的关键内容就说的差不多了，剩余的内容在本书中的讲解都是基于 <strong>不存在 <code>class</code> 的前提条件</strong> 进行的。对于咱们现在的前端开发而言，其实意义不大。</p><p>如果大家想要了解其他的 <strong>类、原型对象、对象关联...</strong> 等等概念的话，还是建议大家去看 <a href="https://www.bilibili.com/video/BV1qD4y1G7YK/?vd_source=391a8dc379e0da60c77490e3221f097a" target="_blank" rel="noreferrer">《深入理解现代 JavaScript》</a></p><h2 id="第二部分总结" tabindex="-1">第二部分总结 <a class="header-anchor" href="#第二部分总结" aria-label="Permalink to &quot;第二部分总结&quot;">​</a></h2><p>那么对于本书的第二部分而言，核心内容主要有 <code>4</code> 点：</p><ol><li><code>this</code> 的绑定规则：这个绑定规则作者在书中介绍的还是非常详尽的</li><li>对象：作者对于对象的使用介绍的也非常详细，值得一读。</li><li>混合对象 “类”：<strong>类在 <code>JS</code> 中是一种可选的设计模式</strong>，这句话我感觉说的非常好，在这里分享给大家</li><li><code>[[prototype]]</code>：原型链是一个面试的时候经常被问的概念，大家需要有所了解。</li></ol><h1 id="总结-2" tabindex="-1">总结 <a class="header-anchor" href="#总结-2" aria-label="Permalink to &quot;总结&quot;">​</a></h1><p><code>OK</code>，那么到这里咱们的 《你不知道的 <code>JavaScript</code> （上卷）》 就全部看完了。</p><p>通过书中的内容，我们可以知道这本当年的神作，确实有很多经典的讲解，比如 <code>LHS &amp;&amp; RHS</code> ，<code>引擎、编辑器、作用域 的对话</code> 都堪称经典内容。</p><p>但是对于现时代的前端开发而言，也确实存在了很多时代的局限问题，比如 <code>行为委托</code> 和 <code>原型</code> 中很多的概念。</p><p>那么咱们这次的《你不知道的 <code>JavaScript</code> （上卷）》就说到这里。</p><p>我是 <code>Sunday</code>，陪大家一起读书，一起分享技术知识，咱们下次再见，<code>88~~~</code></p>',190),T=[N];function A(G,V,K,W,F,Y){return c(),t("div",null,T)}const M=e(C,[["render",A]]);export{I as __pageData,M as default};
